### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AggregateLoginToken {
  _avg: LoginTokenAvgAggregateOutputType
  _count: LoginTokenCountAggregateOutputType
  _max: LoginTokenMaxAggregateOutputType
  _min: LoginTokenMinAggregateOutputType
  _sum: LoginTokenSumAggregateOutputType
  avg: LoginTokenAvgAggregateOutputType
  count: LoginTokenCountAggregateOutputType
  max: LoginTokenMaxAggregateOutputType
  min: LoginTokenMinAggregateOutputType
  sum: LoginTokenSumAggregateOutputType
}

type AggregateRefreshToken {
  _avg: RefreshTokenAvgAggregateOutputType
  _count: RefreshTokenCountAggregateOutputType
  _max: RefreshTokenMaxAggregateOutputType
  _min: RefreshTokenMinAggregateOutputType
  _sum: RefreshTokenSumAggregateOutputType
  avg: RefreshTokenAvgAggregateOutputType
  count: RefreshTokenCountAggregateOutputType
  max: RefreshTokenMaxAggregateOutputType
  min: RefreshTokenMinAggregateOutputType
  sum: RefreshTokenSumAggregateOutputType
}

type AggregateUser {
  _avg: UserAvgAggregateOutputType
  _count: UserCountAggregateOutputType
  _max: UserMaxAggregateOutputType
  _min: UserMinAggregateOutputType
  _sum: UserSumAggregateOutputType
  avg: UserAvgAggregateOutputType
  count: UserCountAggregateOutputType
  max: UserMaxAggregateOutputType
  min: UserMinAggregateOutputType
  sum: UserSumAggregateOutputType
}

type BatchPayload {
  count: Int!
}

"""BigInt custom scalar type"""
scalar BigInt

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  count: NestedIntFilter
  equals: Boolean
  max: NestedBoolFilter
  min: NestedBoolFilter
  not: NestedBoolWithAggregatesFilter
}

"""Date custom scalar type"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  count: NestedIntFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  max: NestedDateTimeFilter
  min: NestedDateTimeFilter
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime]
}

"""Decimal custom scalar type"""
scalar Decimal

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  avg: NestedFloatFilter
  count: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  max: NestedIntFilter
  min: NestedIntFilter
  not: NestedIntWithAggregatesFilter
  notIn: [Int]
  sum: NestedIntFilter
}

"""Json custom scalar type"""
scalar Json

input JsonFilter {
  equals: Json
  not: Json
}

input JsonWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedJsonFilter
  _min: NestedJsonFilter
  count: NestedIntFilter
  equals: Json
  max: NestedJsonFilter
  min: NestedJsonFilter
  not: Json
}

type LoginToken {
  approved: Boolean!
  createdAt: DateTime!
  domain: String!
  email: String!
  expires: DateTime!
  geo: Json!
  id: Int!
  ip: String!
  secret: String!
  user: User!
  userAgent: String!
  userAgentRaw: String!
  userId: Int!
}

type LoginTokenAvgAggregateOutputType {
  id: Float
  userId: Float
}

type LoginTokenCountAggregateOutputType {
  _all: Int!
  approved: Int!
  createdAt: Int!
  domain: Int!
  email: Int!
  expires: Int!
  geo: Int!
  id: Int!
  ip: Int!
  secret: Int!
  userAgent: Int!
  userAgentRaw: Int!
  userId: Int!
}

input LoginTokenCreateInput {
  approved: Boolean
  createdAt: DateTime
  domain: String!
  email: String!
  expires: DateTime!
  geo: Json!
  ip: String!
  secret: String!
  user: UserCreateNestedOneWithoutLoginTokensInput!
  userAgent: String!
  userAgentRaw: String!
}

input LoginTokenCreateManyInput {
  approved: Boolean
  createdAt: DateTime
  domain: String!
  email: String!
  expires: DateTime!
  geo: Json!
  id: Int
  ip: String!
  secret: String!
  userAgent: String!
  userAgentRaw: String!
  userId: Int!
}

input LoginTokenCreateManyUserInput {
  approved: Boolean
  createdAt: DateTime
  domain: String!
  email: String!
  expires: DateTime!
  geo: Json!
  id: Int
  ip: String!
  secret: String!
  userAgent: String!
  userAgentRaw: String!
}

input LoginTokenCreateManyUserInputEnvelope {
  data: LoginTokenCreateManyUserInput!
  skipDuplicates: Boolean
}

input LoginTokenCreateNestedManyWithoutUserInput {
  connect: [LoginTokenWhereUniqueInput]
  connectOrCreate: [LoginTokenCreateOrConnectWithoutUserInput]
  create: [LoginTokenCreateWithoutUserInput]
  createMany: LoginTokenCreateManyUserInputEnvelope
}

input LoginTokenCreateOrConnectWithoutUserInput {
  create: LoginTokenUncheckedCreateWithoutUserInput!
  where: LoginTokenWhereUniqueInput!
}

input LoginTokenCreateWithoutUserInput {
  approved: Boolean
  createdAt: DateTime
  domain: String!
  email: String!
  expires: DateTime!
  geo: Json!
  ip: String!
  secret: String!
  userAgent: String!
  userAgentRaw: String!
}

input LoginTokenListRelationFilter {
  every: LoginTokenWhereInput
  none: LoginTokenWhereInput
  some: LoginTokenWhereInput
}

type LoginTokenMaxAggregateOutputType {
  approved: Boolean
  createdAt: DateTime
  domain: String
  email: String
  expires: DateTime
  id: Int
  ip: String
  secret: String
  userAgent: String
  userAgentRaw: String
  userId: Int
}

type LoginTokenMinAggregateOutputType {
  approved: Boolean
  createdAt: DateTime
  domain: String
  email: String
  expires: DateTime
  id: Int
  ip: String
  secret: String
  userAgent: String
  userAgentRaw: String
  userId: Int
}

input LoginTokenOrderByInput {
  approved: SortOrder
  createdAt: SortOrder
  domain: SortOrder
  email: SortOrder
  expires: SortOrder
  geo: SortOrder
  id: SortOrder
  ip: SortOrder
  secret: SortOrder
  userAgent: SortOrder
  userAgentRaw: SortOrder
  userId: SortOrder
}

enum LoginTokenScalarFieldEnum {
  approved
  createdAt
  domain
  email
  expires
  geo
  id
  ip
  secret
  userAgent
  userAgentRaw
  userId
}

input LoginTokenScalarWhereInput {
  AND: [LoginTokenScalarWhereInput]
  NOT: [LoginTokenScalarWhereInput]
  OR: [LoginTokenScalarWhereInput]
  approved: BoolFilter
  createdAt: DateTimeFilter
  domain: StringFilter
  email: StringFilter
  expires: DateTimeFilter
  geo: JsonFilter
  id: IntFilter
  ip: StringFilter
  secret: StringFilter
  userAgent: StringFilter
  userAgentRaw: StringFilter
  userId: IntFilter
}

input LoginTokenScalarWhereWithAggregatesInput {
  AND: [LoginTokenScalarWhereWithAggregatesInput]
  NOT: [LoginTokenScalarWhereWithAggregatesInput]
  OR: [LoginTokenScalarWhereWithAggregatesInput]
  approved: BoolWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  domain: StringWithAggregatesFilter
  email: StringWithAggregatesFilter
  expires: DateTimeWithAggregatesFilter
  geo: JsonWithAggregatesFilter
  id: IntWithAggregatesFilter
  ip: StringWithAggregatesFilter
  secret: StringWithAggregatesFilter
  userAgent: StringWithAggregatesFilter
  userAgentRaw: StringWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type LoginTokenSumAggregateOutputType {
  id: Int
  userId: Int
}

input LoginTokenUncheckedCreateInput {
  approved: Boolean
  createdAt: DateTime
  domain: String!
  email: String!
  expires: DateTime!
  geo: Json!
  id: Int
  ip: String!
  secret: String!
  userAgent: String!
  userAgentRaw: String!
  userId: Int!
}

input LoginTokenUncheckedCreateNestedManyWithoutUserInput {
  connect: [LoginTokenWhereUniqueInput]
  connectOrCreate: [LoginTokenCreateOrConnectWithoutUserInput]
  create: [LoginTokenCreateWithoutUserInput]
  createMany: LoginTokenCreateManyUserInputEnvelope
}

input LoginTokenUncheckedCreateWithoutUserInput {
  approved: Boolean
  createdAt: DateTime
  domain: String!
  email: String!
  expires: DateTime!
  geo: Json!
  id: Int
  ip: String!
  secret: String!
  userAgent: String!
  userAgentRaw: String!
}

input LoginTokenUncheckedUpdateInput {
  approved: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  id: IntFieldUpdateOperationsInput
  ip: StringFieldUpdateOperationsInput
  secret: StringFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
  userId: IntFieldUpdateOperationsInput
}

input LoginTokenUncheckedUpdateManyInput {
  approved: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  id: IntFieldUpdateOperationsInput
  ip: StringFieldUpdateOperationsInput
  secret: StringFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
  userId: IntFieldUpdateOperationsInput
}

input LoginTokenUncheckedUpdateManyWithoutLoginTokensInput {
  approved: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  id: IntFieldUpdateOperationsInput
  ip: StringFieldUpdateOperationsInput
  secret: StringFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
}

input LoginTokenUncheckedUpdateManyWithoutUserInput {
  connect: [LoginTokenWhereUniqueInput]
  connectOrCreate: [LoginTokenCreateOrConnectWithoutUserInput]
  create: [LoginTokenCreateWithoutUserInput]
  createMany: LoginTokenCreateManyUserInputEnvelope
  delete: [LoginTokenWhereUniqueInput]
  deleteMany: [LoginTokenScalarWhereInput]
  disconnect: [LoginTokenWhereUniqueInput]
  set: [LoginTokenWhereUniqueInput]
  update: [LoginTokenUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [LoginTokenUpdateManyWithWhereWithoutUserInput]
  upsert: [LoginTokenUpsertWithWhereUniqueWithoutUserInput]
}

input LoginTokenUncheckedUpdateWithoutUserInput {
  approved: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  id: IntFieldUpdateOperationsInput
  ip: StringFieldUpdateOperationsInput
  secret: StringFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
}

input LoginTokenUpdateInput {
  approved: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  ip: StringFieldUpdateOperationsInput
  secret: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutLoginTokensInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
}

input LoginTokenUpdateManyMutationInput {
  approved: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  ip: StringFieldUpdateOperationsInput
  secret: StringFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
}

input LoginTokenUpdateManyWithWhereWithoutUserInput {
  data: LoginTokenUncheckedUpdateManyWithoutLoginTokensInput!
  where: LoginTokenScalarWhereInput!
}

input LoginTokenUpdateManyWithoutUserInput {
  connect: [LoginTokenWhereUniqueInput]
  connectOrCreate: [LoginTokenCreateOrConnectWithoutUserInput]
  create: [LoginTokenCreateWithoutUserInput]
  createMany: LoginTokenCreateManyUserInputEnvelope
  delete: [LoginTokenWhereUniqueInput]
  deleteMany: [LoginTokenScalarWhereInput]
  disconnect: [LoginTokenWhereUniqueInput]
  set: [LoginTokenWhereUniqueInput]
  update: [LoginTokenUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [LoginTokenUpdateManyWithWhereWithoutUserInput]
  upsert: [LoginTokenUpsertWithWhereUniqueWithoutUserInput]
}

input LoginTokenUpdateWithWhereUniqueWithoutUserInput {
  data: LoginTokenUncheckedUpdateWithoutUserInput!
  where: LoginTokenWhereUniqueInput!
}

input LoginTokenUpdateWithoutUserInput {
  approved: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  ip: StringFieldUpdateOperationsInput
  secret: StringFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
}

input LoginTokenUpsertWithWhereUniqueWithoutUserInput {
  create: LoginTokenUncheckedCreateWithoutUserInput!
  update: LoginTokenUncheckedUpdateWithoutUserInput!
  where: LoginTokenWhereUniqueInput!
}

input LoginTokenWhereInput {
  AND: [LoginTokenWhereInput]
  NOT: [LoginTokenWhereInput]
  OR: [LoginTokenWhereInput]
  approved: BoolFilter
  createdAt: DateTimeFilter
  domain: StringFilter
  email: StringFilter
  expires: DateTimeFilter
  geo: JsonFilter
  id: IntFilter
  ip: StringFilter
  secret: StringFilter
  user: UserWhereInput
  userAgent: StringFilter
  userAgentRaw: StringFilter
  userId: IntFilter
}

input LoginTokenWhereUniqueInput {
  id: Int
}

type Mutation {
  createOneLoginToken(data: LoginTokenCreateInput!): LoginToken!
  createOneRefreshToken(data: RefreshTokenCreateInput!): RefreshToken!
  createOneUser(data: UserCreateInput!): User!
  deleteManyLoginToken(where: LoginTokenWhereInput): BatchPayload!
  deleteManyRefreshToken(where: RefreshTokenWhereInput): BatchPayload!
  deleteManyUser(where: UserWhereInput): BatchPayload!
  deleteOneLoginToken(where: LoginTokenWhereUniqueInput!): LoginToken
  deleteOneRefreshToken(where: RefreshTokenWhereUniqueInput!): RefreshToken
  deleteOneUser(where: UserWhereUniqueInput!): User
  login(email: String!, password: String!): User
  logout: Boolean
  signup(email: String!, name: String, password: String!): User
  updateManyLoginToken(data: LoginTokenUpdateManyMutationInput!, where: LoginTokenWhereInput): BatchPayload!
  updateManyRefreshToken(data: RefreshTokenUpdateManyMutationInput!, where: RefreshTokenWhereInput): BatchPayload!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateOneLoginToken(data: LoginTokenUpdateInput!, where: LoginTokenWhereUniqueInput!): LoginToken!
  updateOneRefreshToken(data: RefreshTokenUpdateInput!, where: RefreshTokenWhereUniqueInput!): RefreshToken!
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  updatePassword(currentPassword: String!, password: String!): Boolean
  upsertOneLoginToken(create: LoginTokenCreateInput!, update: LoginTokenUpdateInput!, where: LoginTokenWhereUniqueInput!): LoginToken!
  upsertOneRefreshToken(create: RefreshTokenCreateInput!, update: RefreshTokenUpdateInput!, where: RefreshTokenWhereUniqueInput!): RefreshToken!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  count: NestedIntFilter
  equals: Boolean
  max: NestedBoolFilter
  min: NestedBoolFilter
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  count: NestedIntFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  max: NestedDateTimeFilter
  min: NestedDateTimeFilter
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  avg: NestedFloatFilter
  count: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  max: NestedIntFilter
  min: NestedIntFilter
  not: NestedIntWithAggregatesFilter
  notIn: [Int]
  sum: NestedIntFilter
}

input NestedJsonFilter {
  equals: Json
  not: Json
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  count: NestedIntNullableFilter
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  max: NestedStringNullableFilter
  min: NestedStringNullableFilter
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  count: NestedIntFilter
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  max: NestedStringFilter
  min: NestedStringFilter
  not: NestedStringWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  aggregateLoginToken(cursor: LoginTokenWhereUniqueInput, distinct: LoginTokenScalarFieldEnum, orderBy: [LoginTokenOrderByInput], skip: Int, take: Int, where: LoginTokenWhereInput): AggregateLoginToken
  aggregateRefreshToken(cursor: RefreshTokenWhereUniqueInput, distinct: RefreshTokenScalarFieldEnum, orderBy: [RefreshTokenOrderByInput], skip: Int, take: Int, where: RefreshTokenWhereInput): AggregateRefreshToken
  aggregateUser(cursor: UserWhereUniqueInput, distinct: UserScalarFieldEnum, orderBy: [UserOrderByInput], skip: Int, take: Int, where: UserWhereInput): AggregateUser
  findFirstLoginToken(cursor: LoginTokenWhereUniqueInput, distinct: LoginTokenScalarFieldEnum, orderBy: [LoginTokenOrderByInput], skip: Int, take: Int, where: LoginTokenWhereInput): LoginToken
  findFirstRefreshToken(cursor: RefreshTokenWhereUniqueInput, distinct: RefreshTokenScalarFieldEnum, orderBy: [RefreshTokenOrderByInput], skip: Int, take: Int, where: RefreshTokenWhereInput): RefreshToken
  findFirstUser(cursor: UserWhereUniqueInput, distinct: UserScalarFieldEnum, orderBy: [UserOrderByInput], skip: Int, take: Int, where: UserWhereInput): User
  findManyLoginToken(cursor: LoginTokenWhereUniqueInput, distinct: LoginTokenScalarFieldEnum, orderBy: [LoginTokenOrderByInput], skip: Int, take: Int, where: LoginTokenWhereInput): [LoginToken!]!
  findManyLoginTokenCount(cursor: LoginTokenWhereUniqueInput, distinct: LoginTokenScalarFieldEnum, orderBy: [LoginTokenOrderByInput], skip: Int, take: Int, where: LoginTokenWhereInput): Int!
  findManyRefreshToken(cursor: RefreshTokenWhereUniqueInput, distinct: RefreshTokenScalarFieldEnum, orderBy: [RefreshTokenOrderByInput], skip: Int, take: Int, where: RefreshTokenWhereInput): [RefreshToken!]!
  findManyRefreshTokenCount(cursor: RefreshTokenWhereUniqueInput, distinct: RefreshTokenScalarFieldEnum, orderBy: [RefreshTokenOrderByInput], skip: Int, take: Int, where: RefreshTokenWhereInput): Int!
  findManyUser(cursor: UserWhereUniqueInput, distinct: UserScalarFieldEnum, orderBy: [UserOrderByInput], skip: Int, take: Int, where: UserWhereInput): [User!]!
  findManyUserCount(cursor: UserWhereUniqueInput, distinct: UserScalarFieldEnum, orderBy: [UserOrderByInput], skip: Int, take: Int, where: UserWhereInput): Int!
  findUniqueLoginToken(where: LoginTokenWhereUniqueInput!): LoginToken
  findUniqueRefreshToken(where: RefreshTokenWhereUniqueInput!): RefreshToken
  findUniqueUser(where: UserWhereUniqueInput!): User
  me: User
}

enum QueryMode {
  default
  insensitive
}

type RefreshToken {
  createdAt: DateTime!
  expires: DateTime!
  geo: Json!
  ip: String!
  lastActive: DateTime!
  loginTokenId: Int!
  user: User!
  userAgent: String!
  userAgentRaw: String!
  userId: Int!
  value: String!
}

type RefreshTokenAvgAggregateOutputType {
  loginTokenId: Float
  userId: Float
}

type RefreshTokenCountAggregateOutputType {
  _all: Int!
  createdAt: Int!
  expires: Int!
  geo: Int!
  ip: Int!
  lastActive: Int!
  loginTokenId: Int!
  userAgent: Int!
  userAgentRaw: Int!
  userId: Int!
  value: Int!
}

input RefreshTokenCreateInput {
  createdAt: DateTime
  expires: DateTime!
  geo: Json!
  ip: String!
  lastActive: DateTime
  loginTokenId: Int!
  user: UserCreateNestedOneWithoutRefreshTokensInput!
  userAgent: String!
  userAgentRaw: String!
  value: String!
}

input RefreshTokenCreateManyInput {
  createdAt: DateTime
  expires: DateTime!
  geo: Json!
  ip: String!
  lastActive: DateTime
  loginTokenId: Int!
  userAgent: String!
  userAgentRaw: String!
  userId: Int!
  value: String!
}

input RefreshTokenCreateManyUserInput {
  createdAt: DateTime
  expires: DateTime!
  geo: Json!
  ip: String!
  lastActive: DateTime
  loginTokenId: Int!
  userAgent: String!
  userAgentRaw: String!
  value: String!
}

input RefreshTokenCreateManyUserInputEnvelope {
  data: RefreshTokenCreateManyUserInput!
  skipDuplicates: Boolean
}

input RefreshTokenCreateNestedManyWithoutUserInput {
  connect: [RefreshTokenWhereUniqueInput]
  connectOrCreate: [RefreshTokenCreateOrConnectWithoutUserInput]
  create: [RefreshTokenCreateWithoutUserInput]
  createMany: RefreshTokenCreateManyUserInputEnvelope
}

input RefreshTokenCreateOrConnectWithoutUserInput {
  create: RefreshTokenUncheckedCreateWithoutUserInput!
  where: RefreshTokenWhereUniqueInput!
}

input RefreshTokenCreateWithoutUserInput {
  createdAt: DateTime
  expires: DateTime!
  geo: Json!
  ip: String!
  lastActive: DateTime
  loginTokenId: Int!
  userAgent: String!
  userAgentRaw: String!
  value: String!
}

input RefreshTokenListRelationFilter {
  every: RefreshTokenWhereInput
  none: RefreshTokenWhereInput
  some: RefreshTokenWhereInput
}

type RefreshTokenMaxAggregateOutputType {
  createdAt: DateTime
  expires: DateTime
  ip: String
  lastActive: DateTime
  loginTokenId: Int
  userAgent: String
  userAgentRaw: String
  userId: Int
  value: String
}

type RefreshTokenMinAggregateOutputType {
  createdAt: DateTime
  expires: DateTime
  ip: String
  lastActive: DateTime
  loginTokenId: Int
  userAgent: String
  userAgentRaw: String
  userId: Int
  value: String
}

input RefreshTokenOrderByInput {
  createdAt: SortOrder
  expires: SortOrder
  geo: SortOrder
  ip: SortOrder
  lastActive: SortOrder
  loginTokenId: SortOrder
  userAgent: SortOrder
  userAgentRaw: SortOrder
  userId: SortOrder
  value: SortOrder
}

enum RefreshTokenScalarFieldEnum {
  createdAt
  expires
  geo
  ip
  lastActive
  loginTokenId
  userAgent
  userAgentRaw
  userId
  value
}

input RefreshTokenScalarWhereInput {
  AND: [RefreshTokenScalarWhereInput]
  NOT: [RefreshTokenScalarWhereInput]
  OR: [RefreshTokenScalarWhereInput]
  createdAt: DateTimeFilter
  expires: DateTimeFilter
  geo: JsonFilter
  ip: StringFilter
  lastActive: DateTimeFilter
  loginTokenId: IntFilter
  userAgent: StringFilter
  userAgentRaw: StringFilter
  userId: IntFilter
  value: StringFilter
}

input RefreshTokenScalarWhereWithAggregatesInput {
  AND: [RefreshTokenScalarWhereWithAggregatesInput]
  NOT: [RefreshTokenScalarWhereWithAggregatesInput]
  OR: [RefreshTokenScalarWhereWithAggregatesInput]
  createdAt: DateTimeWithAggregatesFilter
  expires: DateTimeWithAggregatesFilter
  geo: JsonWithAggregatesFilter
  ip: StringWithAggregatesFilter
  lastActive: DateTimeWithAggregatesFilter
  loginTokenId: IntWithAggregatesFilter
  userAgent: StringWithAggregatesFilter
  userAgentRaw: StringWithAggregatesFilter
  userId: IntWithAggregatesFilter
  value: StringWithAggregatesFilter
}

type RefreshTokenSumAggregateOutputType {
  loginTokenId: Int
  userId: Int
}

input RefreshTokenUncheckedCreateInput {
  createdAt: DateTime
  expires: DateTime!
  geo: Json!
  ip: String!
  lastActive: DateTime
  loginTokenId: Int!
  userAgent: String!
  userAgentRaw: String!
  userId: Int!
  value: String!
}

input RefreshTokenUncheckedCreateNestedManyWithoutUserInput {
  connect: [RefreshTokenWhereUniqueInput]
  connectOrCreate: [RefreshTokenCreateOrConnectWithoutUserInput]
  create: [RefreshTokenCreateWithoutUserInput]
  createMany: RefreshTokenCreateManyUserInputEnvelope
}

input RefreshTokenUncheckedCreateWithoutUserInput {
  createdAt: DateTime
  expires: DateTime!
  geo: Json!
  ip: String!
  lastActive: DateTime
  loginTokenId: Int!
  userAgent: String!
  userAgentRaw: String!
  value: String!
}

input RefreshTokenUncheckedUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  ip: StringFieldUpdateOperationsInput
  lastActive: DateTimeFieldUpdateOperationsInput
  loginTokenId: IntFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
  userId: IntFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input RefreshTokenUncheckedUpdateManyInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  ip: StringFieldUpdateOperationsInput
  lastActive: DateTimeFieldUpdateOperationsInput
  loginTokenId: IntFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
  userId: IntFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input RefreshTokenUncheckedUpdateManyWithoutRefreshTokensInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  ip: StringFieldUpdateOperationsInput
  lastActive: DateTimeFieldUpdateOperationsInput
  loginTokenId: IntFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input RefreshTokenUncheckedUpdateManyWithoutUserInput {
  connect: [RefreshTokenWhereUniqueInput]
  connectOrCreate: [RefreshTokenCreateOrConnectWithoutUserInput]
  create: [RefreshTokenCreateWithoutUserInput]
  createMany: RefreshTokenCreateManyUserInputEnvelope
  delete: [RefreshTokenWhereUniqueInput]
  deleteMany: [RefreshTokenScalarWhereInput]
  disconnect: [RefreshTokenWhereUniqueInput]
  set: [RefreshTokenWhereUniqueInput]
  update: [RefreshTokenUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [RefreshTokenUpdateManyWithWhereWithoutUserInput]
  upsert: [RefreshTokenUpsertWithWhereUniqueWithoutUserInput]
}

input RefreshTokenUncheckedUpdateWithoutUserInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  ip: StringFieldUpdateOperationsInput
  lastActive: DateTimeFieldUpdateOperationsInput
  loginTokenId: IntFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input RefreshTokenUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  ip: StringFieldUpdateOperationsInput
  lastActive: DateTimeFieldUpdateOperationsInput
  loginTokenId: IntFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutRefreshTokensInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input RefreshTokenUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  ip: StringFieldUpdateOperationsInput
  lastActive: DateTimeFieldUpdateOperationsInput
  loginTokenId: IntFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input RefreshTokenUpdateManyWithWhereWithoutUserInput {
  data: RefreshTokenUncheckedUpdateManyWithoutRefreshTokensInput!
  where: RefreshTokenScalarWhereInput!
}

input RefreshTokenUpdateManyWithoutUserInput {
  connect: [RefreshTokenWhereUniqueInput]
  connectOrCreate: [RefreshTokenCreateOrConnectWithoutUserInput]
  create: [RefreshTokenCreateWithoutUserInput]
  createMany: RefreshTokenCreateManyUserInputEnvelope
  delete: [RefreshTokenWhereUniqueInput]
  deleteMany: [RefreshTokenScalarWhereInput]
  disconnect: [RefreshTokenWhereUniqueInput]
  set: [RefreshTokenWhereUniqueInput]
  update: [RefreshTokenUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [RefreshTokenUpdateManyWithWhereWithoutUserInput]
  upsert: [RefreshTokenUpsertWithWhereUniqueWithoutUserInput]
}

input RefreshTokenUpdateWithWhereUniqueWithoutUserInput {
  data: RefreshTokenUncheckedUpdateWithoutUserInput!
  where: RefreshTokenWhereUniqueInput!
}

input RefreshTokenUpdateWithoutUserInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  ip: StringFieldUpdateOperationsInput
  lastActive: DateTimeFieldUpdateOperationsInput
  loginTokenId: IntFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input RefreshTokenUpsertWithWhereUniqueWithoutUserInput {
  create: RefreshTokenUncheckedCreateWithoutUserInput!
  update: RefreshTokenUncheckedUpdateWithoutUserInput!
  where: RefreshTokenWhereUniqueInput!
}

input RefreshTokenWhereInput {
  AND: [RefreshTokenWhereInput]
  NOT: [RefreshTokenWhereInput]
  OR: [RefreshTokenWhereInput]
  createdAt: DateTimeFilter
  expires: DateTimeFilter
  geo: JsonFilter
  ip: StringFilter
  lastActive: DateTimeFilter
  loginTokenId: IntFilter
  user: UserWhereInput
  userAgent: StringFilter
  userAgentRaw: StringFilter
  userId: IntFilter
  value: StringFilter
}

input RefreshTokenWhereUniqueInput {
  loginTokenId: Int
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  count: NestedIntNullableFilter
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  max: NestedStringNullableFilter
  min: NestedStringNullableFilter
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  count: NestedIntFilter
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  max: NestedStringFilter
  min: NestedStringFilter
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

type User {
  createdAt: DateTime!
  email: String!
  id: Int!
  loginTokens(cursor: LoginTokenWhereUniqueInput, distinct: LoginTokenScalarFieldEnum, orderBy: LoginTokenOrderByInput, skip: Int, take: Int, where: LoginTokenWhereInput): [LoginToken!]!
  name: String
  password: String
  refreshTokens(cursor: RefreshTokenWhereUniqueInput, distinct: RefreshTokenScalarFieldEnum, orderBy: RefreshTokenOrderByInput, skip: Int, take: Int, where: RefreshTokenWhereInput): [RefreshToken!]!
  updatedAt: DateTime!
}

type UserAvgAggregateOutputType {
  id: Float
}

type UserCountAggregateOutputType {
  _all: Int!
  createdAt: Int!
  email: Int!
  id: Int!
  name: Int!
  password: Int!
  updatedAt: Int!
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  loginTokens: LoginTokenCreateNestedManyWithoutUserInput
  name: String
  password: String
  refreshTokens: RefreshTokenCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateManyInput {
  createdAt: DateTime
  email: String!
  id: Int
  name: String
  password: String
  updatedAt: DateTime
}

input UserCreateNestedOneWithoutLoginTokensInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutLoginTokensInput
  create: UserUncheckedCreateWithoutLoginTokensInput
}

input UserCreateNestedOneWithoutRefreshTokensInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRefreshTokensInput
  create: UserUncheckedCreateWithoutRefreshTokensInput
}

input UserCreateOrConnectWithoutLoginTokensInput {
  create: UserUncheckedCreateWithoutLoginTokensInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutRefreshTokensInput {
  create: UserUncheckedCreateWithoutRefreshTokensInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutLoginTokensInput {
  createdAt: DateTime
  email: String!
  name: String
  password: String
  refreshTokens: RefreshTokenCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateWithoutRefreshTokensInput {
  createdAt: DateTime
  email: String!
  loginTokens: LoginTokenCreateNestedManyWithoutUserInput
  name: String
  password: String
  updatedAt: DateTime
}

type UserMaxAggregateOutputType {
  createdAt: DateTime
  email: String
  id: Int
  name: String
  password: String
  updatedAt: DateTime
}

type UserMinAggregateOutputType {
  createdAt: DateTime
  email: String
  id: Int
  name: String
  password: String
  updatedAt: DateTime
}

input UserOrderByInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  email
  id
  name
  password
  updatedAt
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput]
  NOT: [UserScalarWhereWithAggregatesInput]
  OR: [UserScalarWhereWithAggregatesInput]
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringNullableWithAggregatesFilter
  password: StringNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type UserSumAggregateOutputType {
  id: Int
}

input UserUncheckedCreateInput {
  createdAt: DateTime
  email: String!
  id: Int
  loginTokens: LoginTokenUncheckedCreateNestedManyWithoutUserInput
  name: String
  password: String
  refreshTokens: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserUncheckedCreateWithoutLoginTokensInput {
  createdAt: DateTime
  email: String!
  id: Int
  name: String
  password: String
  refreshTokens: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserUncheckedCreateWithoutRefreshTokensInput {
  createdAt: DateTime
  email: String!
  id: Int
  loginTokens: LoginTokenUncheckedCreateNestedManyWithoutUserInput
  name: String
  password: String
  updatedAt: DateTime
}

input UserUncheckedUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  loginTokens: LoginTokenUncheckedUpdateManyWithoutUserInput
  name: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  refreshTokens: RefreshTokenUncheckedUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUncheckedUpdateManyInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUncheckedUpdateWithoutLoginTokensInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  refreshTokens: RefreshTokenUncheckedUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUncheckedUpdateWithoutRefreshTokensInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  loginTokens: LoginTokenUncheckedUpdateManyWithoutUserInput
  name: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  loginTokens: LoginTokenUpdateManyWithoutUserInput
  name: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  refreshTokens: RefreshTokenUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutLoginTokensInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutLoginTokensInput
  create: UserUncheckedCreateWithoutLoginTokensInput
  update: UserUncheckedUpdateWithoutLoginTokensInput
  upsert: UserUpsertWithoutLoginTokensInput
}

input UserUpdateOneRequiredWithoutRefreshTokensInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRefreshTokensInput
  create: UserUncheckedCreateWithoutRefreshTokensInput
  update: UserUncheckedUpdateWithoutRefreshTokensInput
  upsert: UserUpsertWithoutRefreshTokensInput
}

input UserUpdateWithoutLoginTokensInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  refreshTokens: RefreshTokenUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutRefreshTokensInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  loginTokens: LoginTokenUpdateManyWithoutUserInput
  name: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpsertWithoutLoginTokensInput {
  create: UserUncheckedCreateWithoutLoginTokensInput!
  update: UserUncheckedUpdateWithoutLoginTokensInput!
}

input UserUpsertWithoutRefreshTokensInput {
  create: UserUncheckedCreateWithoutRefreshTokensInput!
  update: UserUncheckedUpdateWithoutRefreshTokensInput!
}

input UserWhereInput {
  AND: [UserWhereInput]
  NOT: [UserWhereInput]
  OR: [UserWhereInput]
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  loginTokens: LoginTokenListRelationFilter
  name: StringNullableFilter
  password: StringNullableFilter
  refreshTokens: RefreshTokenListRelationFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
