### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AggregateCollection {
  _count: CollectionCountAggregateOutputType
  _max: CollectionMaxAggregateOutputType
  _min: CollectionMinAggregateOutputType
  count: CollectionCountAggregateOutputType
  max: CollectionMaxAggregateOutputType
  min: CollectionMinAggregateOutputType
}

type AggregateComment {
  _count: CommentCountAggregateOutputType
  _max: CommentMaxAggregateOutputType
  _min: CommentMinAggregateOutputType
  count: CommentCountAggregateOutputType
  max: CommentMaxAggregateOutputType
  min: CommentMinAggregateOutputType
}

type AggregateItem {
  _count: ItemCountAggregateOutputType
  _max: ItemMaxAggregateOutputType
  _min: ItemMinAggregateOutputType
  count: ItemCountAggregateOutputType
  max: ItemMaxAggregateOutputType
  min: ItemMinAggregateOutputType
}

type AggregateLoginToken {
  _count: LoginTokenCountAggregateOutputType
  _max: LoginTokenMaxAggregateOutputType
  _min: LoginTokenMinAggregateOutputType
  count: LoginTokenCountAggregateOutputType
  max: LoginTokenMaxAggregateOutputType
  min: LoginTokenMinAggregateOutputType
}

type AggregateRefreshToken {
  _count: RefreshTokenCountAggregateOutputType
  _max: RefreshTokenMaxAggregateOutputType
  _min: RefreshTokenMinAggregateOutputType
  count: RefreshTokenCountAggregateOutputType
  max: RefreshTokenMaxAggregateOutputType
  min: RefreshTokenMinAggregateOutputType
}

type AggregateRequest {
  _count: RequestCountAggregateOutputType
  _max: RequestMaxAggregateOutputType
  _min: RequestMinAggregateOutputType
  count: RequestCountAggregateOutputType
  max: RequestMaxAggregateOutputType
  min: RequestMinAggregateOutputType
}

type AggregateStory {
  _count: StoryCountAggregateOutputType
  _max: StoryMaxAggregateOutputType
  _min: StoryMinAggregateOutputType
  count: StoryCountAggregateOutputType
  max: StoryMaxAggregateOutputType
  min: StoryMinAggregateOutputType
}

type AggregateUser {
  _count: UserCountAggregateOutputType
  _max: UserMaxAggregateOutputType
  _min: UserMinAggregateOutputType
  count: UserCountAggregateOutputType
  max: UserMaxAggregateOutputType
  min: UserMinAggregateOutputType
}

type BatchPayload {
  count: Int!
}

"""BigInt custom scalar type"""
scalar BigInt

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  count: NestedIntFilter
  equals: Boolean
  max: NestedBoolFilter
  min: NestedBoolFilter
  not: NestedBoolWithAggregatesFilter
}

type Collection {
  description: String
  doImage: Json
  id: String!
  name: String!
  stories(cursor: StoryWhereUniqueInput, distinct: StoryScalarFieldEnum, orderBy: StoryOrderByInput, skip: Int, take: Int, where: StoryWhereInput): [Story!]!
  storyOrder: [String!]!
}

type CollectionCountAggregateOutputType {
  _all: Int!
  description: Int!
  doImage: Int!
  id: Int!
  name: Int!
  storyOrder: Int!
}

input CollectionCreateInput {
  description: String
  doImage: Json
  id: String
  name: String!
  stories: StoryCreateNestedManyWithoutCollectionInput
  storyOrder: [String]
}

input CollectionCreateManyInput {
  description: String
  doImage: Json
  id: String
  name: String!
  storyOrder: [String]
}

input CollectionCreateManystoryOrderInput {
  set: String!
}

input CollectionCreateNestedOneWithoutStoriesInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutStoriesInput
  create: CollectionUncheckedCreateWithoutStoriesInput
}

input CollectionCreateOrConnectWithoutStoriesInput {
  create: CollectionUncheckedCreateWithoutStoriesInput!
  where: CollectionWhereUniqueInput!
}

input CollectionCreateWithoutStoriesInput {
  description: String
  doImage: Json
  id: String
  name: String!
  storyOrder: [String]
}

input CollectionCreatestoryOrderInput {
  set: String!
}

type CollectionMaxAggregateOutputType {
  description: String
  id: String
  name: String
}

type CollectionMinAggregateOutputType {
  description: String
  id: String
  name: String
}

input CollectionOrderByInput {
  description: SortOrder
  doImage: SortOrder
  id: SortOrder
  name: SortOrder
  storyOrder: SortOrder
}

input CollectionRelationFilter {
  is: CollectionWhereInput
  isNot: CollectionWhereInput
}

enum CollectionScalarFieldEnum {
  description
  doImage
  id
  name
  storyOrder
}

input CollectionScalarWhereWithAggregatesInput {
  AND: [CollectionScalarWhereWithAggregatesInput]
  NOT: [CollectionScalarWhereWithAggregatesInput]
  OR: [CollectionScalarWhereWithAggregatesInput]
  description: StringNullableWithAggregatesFilter
  doImage: JsonNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  storyOrder: StringNullableListFilter
}

input CollectionUncheckedCreateInput {
  description: String
  doImage: Json
  id: String
  name: String!
  stories: StoryUncheckedCreateNestedManyWithoutCollectionInput
  storyOrder: [String]
}

input CollectionUncheckedCreateWithoutStoriesInput {
  description: String
  doImage: Json
  id: String
  name: String!
  storyOrder: [String]
}

input CollectionUncheckedUpdateInput {
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  stories: StoryUncheckedUpdateManyWithoutCollectionInput
  storyOrder: [String]
}

input CollectionUncheckedUpdateManyInput {
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  storyOrder: [String]
}

input CollectionUncheckedUpdateWithoutStoriesInput {
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  storyOrder: [String]
}

input CollectionUpdateInput {
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  stories: StoryUpdateManyWithoutCollectionInput
  storyOrder: [String]
}

input CollectionUpdateManyMutationInput {
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  storyOrder: [String]
}

input CollectionUpdateOneRequiredWithoutStoriesInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutStoriesInput
  create: CollectionUncheckedCreateWithoutStoriesInput
  update: CollectionUncheckedUpdateWithoutStoriesInput
  upsert: CollectionUpsertWithoutStoriesInput
}

input CollectionUpdateWithoutStoriesInput {
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  storyOrder: [String]
}

input CollectionUpdatestoryOrderInput {
  push: [String]
  set: [String]
}

input CollectionUpsertWithoutStoriesInput {
  create: CollectionUncheckedCreateWithoutStoriesInput!
  update: CollectionUncheckedUpdateWithoutStoriesInput!
}

input CollectionWhereInput {
  AND: [CollectionWhereInput]
  NOT: [CollectionWhereInput]
  OR: [CollectionWhereInput]
  description: StringNullableFilter
  doImage: JsonNullableFilter
  id: StringFilter
  name: StringFilter
  stories: StoryListRelationFilter
  storyOrder: StringNullableListFilter
}

input CollectionWhereUniqueInput {
  id: String
}

type Comment {
  createdAt: DateTime
  id: String!
  message: String!
  messageType: MessageType!
  request: Request!
  requestId: String!
  user: User!
  userId: String!
}

type CommentCountAggregateOutputType {
  _all: Int!
  createdAt: Int!
  id: Int!
  message: Int!
  messageType: Int!
  requestId: Int!
  userId: Int!
}

input CommentCreateInput {
  createdAt: DateTime
  id: String
  message: String!
  messageType: MessageType!
  request: RequestCreateNestedOneWithoutCommentsInput!
  user: UserCreateNestedOneWithoutCommentsInput!
}

input CommentCreateManyInput {
  createdAt: DateTime
  id: String
  message: String!
  messageType: MessageType!
  requestId: String!
  userId: String!
}

input CommentCreateManyRequestInput {
  createdAt: DateTime
  id: String
  message: String!
  messageType: MessageType!
  userId: String!
}

input CommentCreateManyRequestInputEnvelope {
  data: CommentCreateManyRequestInput!
  skipDuplicates: Boolean
}

input CommentCreateManyUserInput {
  createdAt: DateTime
  id: String
  message: String!
  messageType: MessageType!
  requestId: String!
}

input CommentCreateManyUserInputEnvelope {
  data: CommentCreateManyUserInput!
  skipDuplicates: Boolean
}

input CommentCreateNestedManyWithoutRequestInput {
  connect: [CommentWhereUniqueInput]
  connectOrCreate: [CommentCreateOrConnectWithoutRequestInput]
  create: [CommentCreateWithoutRequestInput]
  createMany: CommentCreateManyRequestInputEnvelope
}

input CommentCreateNestedManyWithoutUserInput {
  connect: [CommentWhereUniqueInput]
  connectOrCreate: [CommentCreateOrConnectWithoutUserInput]
  create: [CommentCreateWithoutUserInput]
  createMany: CommentCreateManyUserInputEnvelope
}

input CommentCreateOrConnectWithoutRequestInput {
  create: CommentUncheckedCreateWithoutRequestInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateOrConnectWithoutUserInput {
  create: CommentUncheckedCreateWithoutUserInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateWithoutRequestInput {
  createdAt: DateTime
  id: String
  message: String!
  messageType: MessageType!
  user: UserCreateNestedOneWithoutCommentsInput!
}

input CommentCreateWithoutUserInput {
  createdAt: DateTime
  id: String
  message: String!
  messageType: MessageType!
  request: RequestCreateNestedOneWithoutCommentsInput!
}

input CommentListRelationFilter {
  every: CommentWhereInput
  none: CommentWhereInput
  some: CommentWhereInput
}

type CommentMaxAggregateOutputType {
  createdAt: DateTime
  id: String
  message: String
  messageType: MessageType
  requestId: String
  userId: String
}

type CommentMinAggregateOutputType {
  createdAt: DateTime
  id: String
  message: String
  messageType: MessageType
  requestId: String
  userId: String
}

input CommentOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  message: SortOrder
  messageType: SortOrder
  requestId: SortOrder
  userId: SortOrder
}

enum CommentScalarFieldEnum {
  createdAt
  id
  message
  messageType
  requestId
  userId
}

input CommentScalarWhereInput {
  AND: [CommentScalarWhereInput]
  NOT: [CommentScalarWhereInput]
  OR: [CommentScalarWhereInput]
  createdAt: DateTimeNullableFilter
  id: StringFilter
  message: StringFilter
  messageType: EnumMessageTypeFilter
  requestId: StringFilter
  userId: StringFilter
}

input CommentScalarWhereWithAggregatesInput {
  AND: [CommentScalarWhereWithAggregatesInput]
  NOT: [CommentScalarWhereWithAggregatesInput]
  OR: [CommentScalarWhereWithAggregatesInput]
  createdAt: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  message: StringWithAggregatesFilter
  messageType: EnumMessageTypeWithAggregatesFilter
  requestId: StringWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

input CommentUncheckedCreateInput {
  createdAt: DateTime
  id: String
  message: String!
  messageType: MessageType!
  requestId: String!
  userId: String!
}

input CommentUncheckedCreateNestedManyWithoutRequestInput {
  connect: [CommentWhereUniqueInput]
  connectOrCreate: [CommentCreateOrConnectWithoutRequestInput]
  create: [CommentCreateWithoutRequestInput]
  createMany: CommentCreateManyRequestInputEnvelope
}

input CommentUncheckedCreateNestedManyWithoutUserInput {
  connect: [CommentWhereUniqueInput]
  connectOrCreate: [CommentCreateOrConnectWithoutUserInput]
  create: [CommentCreateWithoutUserInput]
  createMany: CommentCreateManyUserInputEnvelope
}

input CommentUncheckedCreateWithoutRequestInput {
  createdAt: DateTime
  id: String
  message: String!
  messageType: MessageType!
  userId: String!
}

input CommentUncheckedCreateWithoutUserInput {
  createdAt: DateTime
  id: String
  message: String!
  messageType: MessageType!
  requestId: String!
}

input CommentUncheckedUpdateInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  message: StringFieldUpdateOperationsInput
  messageType: EnumMessageTypeFieldUpdateOperationsInput
  requestId: StringFieldUpdateOperationsInput
  userId: StringFieldUpdateOperationsInput
}

input CommentUncheckedUpdateManyInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  message: StringFieldUpdateOperationsInput
  messageType: EnumMessageTypeFieldUpdateOperationsInput
  requestId: StringFieldUpdateOperationsInput
  userId: StringFieldUpdateOperationsInput
}

input CommentUncheckedUpdateManyWithoutCommentsInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  message: StringFieldUpdateOperationsInput
  messageType: EnumMessageTypeFieldUpdateOperationsInput
  requestId: StringFieldUpdateOperationsInput
}

input CommentUncheckedUpdateManyWithoutRequestInput {
  connect: [CommentWhereUniqueInput]
  connectOrCreate: [CommentCreateOrConnectWithoutRequestInput]
  create: [CommentCreateWithoutRequestInput]
  createMany: CommentCreateManyRequestInputEnvelope
  delete: [CommentWhereUniqueInput]
  deleteMany: [CommentScalarWhereInput]
  disconnect: [CommentWhereUniqueInput]
  set: [CommentWhereUniqueInput]
  update: [CommentUpdateWithWhereUniqueWithoutRequestInput]
  updateMany: [CommentUpdateManyWithWhereWithoutRequestInput]
  upsert: [CommentUpsertWithWhereUniqueWithoutRequestInput]
}

input CommentUncheckedUpdateManyWithoutUserInput {
  connect: [CommentWhereUniqueInput]
  connectOrCreate: [CommentCreateOrConnectWithoutUserInput]
  create: [CommentCreateWithoutUserInput]
  createMany: CommentCreateManyUserInputEnvelope
  delete: [CommentWhereUniqueInput]
  deleteMany: [CommentScalarWhereInput]
  disconnect: [CommentWhereUniqueInput]
  set: [CommentWhereUniqueInput]
  update: [CommentUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [CommentUpdateManyWithWhereWithoutUserInput]
  upsert: [CommentUpsertWithWhereUniqueWithoutUserInput]
}

input CommentUncheckedUpdateWithoutRequestInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  message: StringFieldUpdateOperationsInput
  messageType: EnumMessageTypeFieldUpdateOperationsInput
  userId: StringFieldUpdateOperationsInput
}

input CommentUncheckedUpdateWithoutUserInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  message: StringFieldUpdateOperationsInput
  messageType: EnumMessageTypeFieldUpdateOperationsInput
  requestId: StringFieldUpdateOperationsInput
}

input CommentUpdateInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  message: StringFieldUpdateOperationsInput
  messageType: EnumMessageTypeFieldUpdateOperationsInput
  request: RequestUpdateOneRequiredWithoutCommentsInput
  user: UserUpdateOneRequiredWithoutCommentsInput
}

input CommentUpdateManyMutationInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  message: StringFieldUpdateOperationsInput
  messageType: EnumMessageTypeFieldUpdateOperationsInput
}

input CommentUpdateManyWithWhereWithoutRequestInput {
  data: CommentUncheckedUpdateManyWithoutCommentsInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateManyWithWhereWithoutUserInput {
  data: CommentUncheckedUpdateManyWithoutCommentsInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateManyWithoutRequestInput {
  connect: [CommentWhereUniqueInput]
  connectOrCreate: [CommentCreateOrConnectWithoutRequestInput]
  create: [CommentCreateWithoutRequestInput]
  createMany: CommentCreateManyRequestInputEnvelope
  delete: [CommentWhereUniqueInput]
  deleteMany: [CommentScalarWhereInput]
  disconnect: [CommentWhereUniqueInput]
  set: [CommentWhereUniqueInput]
  update: [CommentUpdateWithWhereUniqueWithoutRequestInput]
  updateMany: [CommentUpdateManyWithWhereWithoutRequestInput]
  upsert: [CommentUpsertWithWhereUniqueWithoutRequestInput]
}

input CommentUpdateManyWithoutUserInput {
  connect: [CommentWhereUniqueInput]
  connectOrCreate: [CommentCreateOrConnectWithoutUserInput]
  create: [CommentCreateWithoutUserInput]
  createMany: CommentCreateManyUserInputEnvelope
  delete: [CommentWhereUniqueInput]
  deleteMany: [CommentScalarWhereInput]
  disconnect: [CommentWhereUniqueInput]
  set: [CommentWhereUniqueInput]
  update: [CommentUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [CommentUpdateManyWithWhereWithoutUserInput]
  upsert: [CommentUpsertWithWhereUniqueWithoutUserInput]
}

input CommentUpdateWithWhereUniqueWithoutRequestInput {
  data: CommentUncheckedUpdateWithoutRequestInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithWhereUniqueWithoutUserInput {
  data: CommentUncheckedUpdateWithoutUserInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithoutRequestInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  message: StringFieldUpdateOperationsInput
  messageType: EnumMessageTypeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutCommentsInput
}

input CommentUpdateWithoutUserInput {
  createdAt: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  message: StringFieldUpdateOperationsInput
  messageType: EnumMessageTypeFieldUpdateOperationsInput
  request: RequestUpdateOneRequiredWithoutCommentsInput
}

input CommentUpsertWithWhereUniqueWithoutRequestInput {
  create: CommentUncheckedCreateWithoutRequestInput!
  update: CommentUncheckedUpdateWithoutRequestInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithWhereUniqueWithoutUserInput {
  create: CommentUncheckedCreateWithoutUserInput!
  update: CommentUncheckedUpdateWithoutUserInput!
  where: CommentWhereUniqueInput!
}

input CommentWhereInput {
  AND: [CommentWhereInput]
  NOT: [CommentWhereInput]
  OR: [CommentWhereInput]
  createdAt: DateTimeNullableFilter
  id: StringFilter
  message: StringFilter
  messageType: EnumMessageTypeFilter
  request: RequestWhereInput
  requestId: StringFilter
  user: UserWhereInput
  userId: StringFilter
}

input CommentWhereUniqueInput {
  id: String
}

"""Date custom scalar type"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  count: NestedIntNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  max: NestedDateTimeNullableFilter
  min: NestedDateTimeNullableFilter
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  count: NestedIntFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  max: NestedDateTimeFilter
  min: NestedDateTimeFilter
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime]
}

"""Decimal custom scalar type"""
scalar Decimal

input EnumMessageTypeFieldUpdateOperationsInput {
  set: MessageType
}

input EnumMessageTypeFilter {
  equals: MessageType
  in: [MessageType]
  not: NestedEnumMessageTypeFilter
  notIn: [MessageType]
}

input EnumMessageTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumMessageTypeFilter
  _min: NestedEnumMessageTypeFilter
  count: NestedIntFilter
  equals: MessageType
  in: [MessageType]
  max: NestedEnumMessageTypeFilter
  min: NestedEnumMessageTypeFilter
  not: NestedEnumMessageTypeWithAggregatesFilter
  notIn: [MessageType]
}

type Item {
  description: String
  doImage: Json
  id: String!
  name: String!
  stories(cursor: StoryWhereUniqueInput, distinct: StoryScalarFieldEnum, orderBy: StoryOrderByInput, skip: Int, take: Int, where: StoryWhereInput): [Story!]!
}

type ItemCountAggregateOutputType {
  _all: Int!
  description: Int!
  doImage: Int!
  id: Int!
  name: Int!
}

input ItemCreateInput {
  description: String
  doImage: Json
  id: String
  name: String!
  stories: StoryCreateNestedManyWithoutItemsInput
}

input ItemCreateManyInput {
  description: String
  doImage: Json
  id: String
  name: String!
}

input ItemCreateNestedManyWithoutStoriesInput {
  connect: [ItemWhereUniqueInput]
  connectOrCreate: [ItemCreateOrConnectWithoutStoriesInput]
  create: [ItemCreateWithoutStoriesInput]
}

input ItemCreateOrConnectWithoutStoriesInput {
  create: ItemUncheckedCreateWithoutStoriesInput!
  where: ItemWhereUniqueInput!
}

input ItemCreateWithoutStoriesInput {
  description: String
  doImage: Json
  id: String
  name: String!
}

input ItemListRelationFilter {
  every: ItemWhereInput
  none: ItemWhereInput
  some: ItemWhereInput
}

type ItemMaxAggregateOutputType {
  description: String
  id: String
  name: String
}

type ItemMinAggregateOutputType {
  description: String
  id: String
  name: String
}

input ItemOrderByInput {
  description: SortOrder
  doImage: SortOrder
  id: SortOrder
  name: SortOrder
}

enum ItemScalarFieldEnum {
  description
  doImage
  id
  name
}

input ItemScalarWhereInput {
  AND: [ItemScalarWhereInput]
  NOT: [ItemScalarWhereInput]
  OR: [ItemScalarWhereInput]
  description: StringNullableFilter
  doImage: JsonNullableFilter
  id: StringFilter
  name: StringFilter
}

input ItemScalarWhereWithAggregatesInput {
  AND: [ItemScalarWhereWithAggregatesInput]
  NOT: [ItemScalarWhereWithAggregatesInput]
  OR: [ItemScalarWhereWithAggregatesInput]
  description: StringNullableWithAggregatesFilter
  doImage: JsonNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input ItemUncheckedCreateInput {
  description: String
  doImage: Json
  id: String
  name: String!
}

input ItemUncheckedCreateWithoutStoriesInput {
  description: String
  doImage: Json
  id: String
  name: String!
}

input ItemUncheckedUpdateInput {
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ItemUncheckedUpdateManyInput {
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ItemUncheckedUpdateManyWithoutItemsInput {
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ItemUncheckedUpdateWithoutStoriesInput {
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ItemUpdateInput {
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  stories: StoryUpdateManyWithoutItemsInput
}

input ItemUpdateManyMutationInput {
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ItemUpdateManyWithWhereWithoutStoriesInput {
  data: ItemUncheckedUpdateManyWithoutItemsInput!
  where: ItemScalarWhereInput!
}

input ItemUpdateManyWithoutStoriesInput {
  connect: [ItemWhereUniqueInput]
  connectOrCreate: [ItemCreateOrConnectWithoutStoriesInput]
  create: [ItemCreateWithoutStoriesInput]
  delete: [ItemWhereUniqueInput]
  deleteMany: [ItemScalarWhereInput]
  disconnect: [ItemWhereUniqueInput]
  set: [ItemWhereUniqueInput]
  update: [ItemUpdateWithWhereUniqueWithoutStoriesInput]
  updateMany: [ItemUpdateManyWithWhereWithoutStoriesInput]
  upsert: [ItemUpsertWithWhereUniqueWithoutStoriesInput]
}

input ItemUpdateWithWhereUniqueWithoutStoriesInput {
  data: ItemUncheckedUpdateWithoutStoriesInput!
  where: ItemWhereUniqueInput!
}

input ItemUpdateWithoutStoriesInput {
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ItemUpsertWithWhereUniqueWithoutStoriesInput {
  create: ItemUncheckedCreateWithoutStoriesInput!
  update: ItemUncheckedUpdateWithoutStoriesInput!
  where: ItemWhereUniqueInput!
}

input ItemWhereInput {
  AND: [ItemWhereInput]
  NOT: [ItemWhereInput]
  OR: [ItemWhereInput]
  description: StringNullableFilter
  doImage: JsonNullableFilter
  id: StringFilter
  name: StringFilter
  stories: StoryListRelationFilter
}

input ItemWhereUniqueInput {
  id: String
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""Json custom scalar type"""
scalar Json

input JsonFilter {
  equals: Json
  not: Json
}

input JsonNullableFilter {
  equals: Json
  not: Json
}

input JsonNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedJsonNullableFilter
  _min: NestedJsonNullableFilter
  count: NestedIntNullableFilter
  equals: Json
  max: NestedJsonNullableFilter
  min: NestedJsonNullableFilter
  not: Json
}

input JsonWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedJsonFilter
  _min: NestedJsonFilter
  count: NestedIntFilter
  equals: Json
  max: NestedJsonFilter
  min: NestedJsonFilter
  not: Json
}

type LoginToken {
  approved: Boolean!
  createdAt: DateTime!
  domain: String!
  email: String!
  expires: DateTime!
  geo: Json!
  id: String!
  ip: String!
  secret: String!
  user: User!
  userAgent: String!
  userAgentRaw: String!
  userId: String!
}

type LoginTokenCountAggregateOutputType {
  _all: Int!
  approved: Int!
  createdAt: Int!
  domain: Int!
  email: Int!
  expires: Int!
  geo: Int!
  id: Int!
  ip: Int!
  secret: Int!
  userAgent: Int!
  userAgentRaw: Int!
  userId: Int!
}

input LoginTokenCreateInput {
  approved: Boolean
  createdAt: DateTime
  domain: String!
  email: String!
  expires: DateTime!
  geo: Json!
  id: String
  ip: String!
  secret: String!
  user: UserCreateNestedOneWithoutLoginTokensInput!
  userAgent: String!
  userAgentRaw: String!
}

input LoginTokenCreateManyInput {
  approved: Boolean
  createdAt: DateTime
  domain: String!
  email: String!
  expires: DateTime!
  geo: Json!
  id: String
  ip: String!
  secret: String!
  userAgent: String!
  userAgentRaw: String!
  userId: String!
}

input LoginTokenCreateManyUserInput {
  approved: Boolean
  createdAt: DateTime
  domain: String!
  email: String!
  expires: DateTime!
  geo: Json!
  id: String
  ip: String!
  secret: String!
  userAgent: String!
  userAgentRaw: String!
}

input LoginTokenCreateManyUserInputEnvelope {
  data: LoginTokenCreateManyUserInput!
  skipDuplicates: Boolean
}

input LoginTokenCreateNestedManyWithoutUserInput {
  connect: [LoginTokenWhereUniqueInput]
  connectOrCreate: [LoginTokenCreateOrConnectWithoutUserInput]
  create: [LoginTokenCreateWithoutUserInput]
  createMany: LoginTokenCreateManyUserInputEnvelope
}

input LoginTokenCreateOrConnectWithoutUserInput {
  create: LoginTokenUncheckedCreateWithoutUserInput!
  where: LoginTokenWhereUniqueInput!
}

input LoginTokenCreateWithoutUserInput {
  approved: Boolean
  createdAt: DateTime
  domain: String!
  email: String!
  expires: DateTime!
  geo: Json!
  id: String
  ip: String!
  secret: String!
  userAgent: String!
  userAgentRaw: String!
}

input LoginTokenListRelationFilter {
  every: LoginTokenWhereInput
  none: LoginTokenWhereInput
  some: LoginTokenWhereInput
}

type LoginTokenMaxAggregateOutputType {
  approved: Boolean
  createdAt: DateTime
  domain: String
  email: String
  expires: DateTime
  id: String
  ip: String
  secret: String
  userAgent: String
  userAgentRaw: String
  userId: String
}

type LoginTokenMinAggregateOutputType {
  approved: Boolean
  createdAt: DateTime
  domain: String
  email: String
  expires: DateTime
  id: String
  ip: String
  secret: String
  userAgent: String
  userAgentRaw: String
  userId: String
}

input LoginTokenOrderByInput {
  approved: SortOrder
  createdAt: SortOrder
  domain: SortOrder
  email: SortOrder
  expires: SortOrder
  geo: SortOrder
  id: SortOrder
  ip: SortOrder
  secret: SortOrder
  userAgent: SortOrder
  userAgentRaw: SortOrder
  userId: SortOrder
}

enum LoginTokenScalarFieldEnum {
  approved
  createdAt
  domain
  email
  expires
  geo
  id
  ip
  secret
  userAgent
  userAgentRaw
  userId
}

input LoginTokenScalarWhereInput {
  AND: [LoginTokenScalarWhereInput]
  NOT: [LoginTokenScalarWhereInput]
  OR: [LoginTokenScalarWhereInput]
  approved: BoolFilter
  createdAt: DateTimeFilter
  domain: StringFilter
  email: StringFilter
  expires: DateTimeFilter
  geo: JsonFilter
  id: StringFilter
  ip: StringFilter
  secret: StringFilter
  userAgent: StringFilter
  userAgentRaw: StringFilter
  userId: StringFilter
}

input LoginTokenScalarWhereWithAggregatesInput {
  AND: [LoginTokenScalarWhereWithAggregatesInput]
  NOT: [LoginTokenScalarWhereWithAggregatesInput]
  OR: [LoginTokenScalarWhereWithAggregatesInput]
  approved: BoolWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  domain: StringWithAggregatesFilter
  email: StringWithAggregatesFilter
  expires: DateTimeWithAggregatesFilter
  geo: JsonWithAggregatesFilter
  id: StringWithAggregatesFilter
  ip: StringWithAggregatesFilter
  secret: StringWithAggregatesFilter
  userAgent: StringWithAggregatesFilter
  userAgentRaw: StringWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

input LoginTokenUncheckedCreateInput {
  approved: Boolean
  createdAt: DateTime
  domain: String!
  email: String!
  expires: DateTime!
  geo: Json!
  id: String
  ip: String!
  secret: String!
  userAgent: String!
  userAgentRaw: String!
  userId: String!
}

input LoginTokenUncheckedCreateNestedManyWithoutUserInput {
  connect: [LoginTokenWhereUniqueInput]
  connectOrCreate: [LoginTokenCreateOrConnectWithoutUserInput]
  create: [LoginTokenCreateWithoutUserInput]
  createMany: LoginTokenCreateManyUserInputEnvelope
}

input LoginTokenUncheckedCreateWithoutUserInput {
  approved: Boolean
  createdAt: DateTime
  domain: String!
  email: String!
  expires: DateTime!
  geo: Json!
  id: String
  ip: String!
  secret: String!
  userAgent: String!
  userAgentRaw: String!
}

input LoginTokenUncheckedUpdateInput {
  approved: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  id: StringFieldUpdateOperationsInput
  ip: StringFieldUpdateOperationsInput
  secret: StringFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
  userId: StringFieldUpdateOperationsInput
}

input LoginTokenUncheckedUpdateManyInput {
  approved: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  id: StringFieldUpdateOperationsInput
  ip: StringFieldUpdateOperationsInput
  secret: StringFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
  userId: StringFieldUpdateOperationsInput
}

input LoginTokenUncheckedUpdateManyWithoutLoginTokensInput {
  approved: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  id: StringFieldUpdateOperationsInput
  ip: StringFieldUpdateOperationsInput
  secret: StringFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
}

input LoginTokenUncheckedUpdateManyWithoutUserInput {
  connect: [LoginTokenWhereUniqueInput]
  connectOrCreate: [LoginTokenCreateOrConnectWithoutUserInput]
  create: [LoginTokenCreateWithoutUserInput]
  createMany: LoginTokenCreateManyUserInputEnvelope
  delete: [LoginTokenWhereUniqueInput]
  deleteMany: [LoginTokenScalarWhereInput]
  disconnect: [LoginTokenWhereUniqueInput]
  set: [LoginTokenWhereUniqueInput]
  update: [LoginTokenUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [LoginTokenUpdateManyWithWhereWithoutUserInput]
  upsert: [LoginTokenUpsertWithWhereUniqueWithoutUserInput]
}

input LoginTokenUncheckedUpdateWithoutUserInput {
  approved: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  id: StringFieldUpdateOperationsInput
  ip: StringFieldUpdateOperationsInput
  secret: StringFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
}

input LoginTokenUpdateInput {
  approved: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  id: StringFieldUpdateOperationsInput
  ip: StringFieldUpdateOperationsInput
  secret: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutLoginTokensInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
}

input LoginTokenUpdateManyMutationInput {
  approved: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  id: StringFieldUpdateOperationsInput
  ip: StringFieldUpdateOperationsInput
  secret: StringFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
}

input LoginTokenUpdateManyWithWhereWithoutUserInput {
  data: LoginTokenUncheckedUpdateManyWithoutLoginTokensInput!
  where: LoginTokenScalarWhereInput!
}

input LoginTokenUpdateManyWithoutUserInput {
  connect: [LoginTokenWhereUniqueInput]
  connectOrCreate: [LoginTokenCreateOrConnectWithoutUserInput]
  create: [LoginTokenCreateWithoutUserInput]
  createMany: LoginTokenCreateManyUserInputEnvelope
  delete: [LoginTokenWhereUniqueInput]
  deleteMany: [LoginTokenScalarWhereInput]
  disconnect: [LoginTokenWhereUniqueInput]
  set: [LoginTokenWhereUniqueInput]
  update: [LoginTokenUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [LoginTokenUpdateManyWithWhereWithoutUserInput]
  upsert: [LoginTokenUpsertWithWhereUniqueWithoutUserInput]
}

input LoginTokenUpdateWithWhereUniqueWithoutUserInput {
  data: LoginTokenUncheckedUpdateWithoutUserInput!
  where: LoginTokenWhereUniqueInput!
}

input LoginTokenUpdateWithoutUserInput {
  approved: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  id: StringFieldUpdateOperationsInput
  ip: StringFieldUpdateOperationsInput
  secret: StringFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
}

input LoginTokenUpsertWithWhereUniqueWithoutUserInput {
  create: LoginTokenUncheckedCreateWithoutUserInput!
  update: LoginTokenUncheckedUpdateWithoutUserInput!
  where: LoginTokenWhereUniqueInput!
}

input LoginTokenWhereInput {
  AND: [LoginTokenWhereInput]
  NOT: [LoginTokenWhereInput]
  OR: [LoginTokenWhereInput]
  approved: BoolFilter
  createdAt: DateTimeFilter
  domain: StringFilter
  email: StringFilter
  expires: DateTimeFilter
  geo: JsonFilter
  id: StringFilter
  ip: StringFilter
  secret: StringFilter
  user: UserWhereInput
  userAgent: StringFilter
  userAgentRaw: StringFilter
  userId: StringFilter
}

input LoginTokenWhereUniqueInput {
  id: String
}

enum MessageType {
  image
  text
}

type Mutation {
  createOneCollection(data: CollectionCreateInput!): Collection!
  createOneComment(data: CommentCreateInput!): Comment!
  createOneItem(data: ItemCreateInput!): Item!
  createOneLoginToken(data: LoginTokenCreateInput!): LoginToken!
  createOneRefreshToken(data: RefreshTokenCreateInput!): RefreshToken!
  createOneRequest(data: RequestCreateInput!): Request!
  createOneStory(data: StoryCreateInput!): Story!
  createOneUser(data: UserCreateInput!): User!
  deleteManyCollection(where: CollectionWhereInput): BatchPayload!
  deleteManyComment(where: CommentWhereInput): BatchPayload!
  deleteManyItem(where: ItemWhereInput): BatchPayload!
  deleteManyLoginToken(where: LoginTokenWhereInput): BatchPayload!
  deleteManyRefreshToken(where: RefreshTokenWhereInput): BatchPayload!
  deleteManyRequest(where: RequestWhereInput): BatchPayload!
  deleteManyStory(where: StoryWhereInput): BatchPayload!
  deleteManyUser(where: UserWhereInput): BatchPayload!
  deleteOneCollection(where: CollectionWhereUniqueInput!): Collection
  deleteOneComment(where: CommentWhereUniqueInput!): Comment
  deleteOneItem(where: ItemWhereUniqueInput!): Item
  deleteOneLoginToken(where: LoginTokenWhereUniqueInput!): LoginToken
  deleteOneRefreshToken(where: RefreshTokenWhereUniqueInput!): RefreshToken
  deleteOneRequest(where: RequestWhereUniqueInput!): Request
  deleteOneStory(where: StoryWhereUniqueInput!): Story
  deleteOneUser(where: UserWhereUniqueInput!): User
  enterAdmin(admin: String!, id: Int!): JSON
  login(email: String!, password: String!): User
  logout: Boolean
  logoutAdmin: JSON
  signup(email: String!, name: String, password: String!): User
  updateManyCollection(data: CollectionUpdateManyMutationInput!, where: CollectionWhereInput): BatchPayload!
  updateManyComment(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload!
  updateManyItem(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): BatchPayload!
  updateManyLoginToken(data: LoginTokenUpdateManyMutationInput!, where: LoginTokenWhereInput): BatchPayload!
  updateManyRefreshToken(data: RefreshTokenUpdateManyMutationInput!, where: RefreshTokenWhereInput): BatchPayload!
  updateManyRequest(data: RequestUpdateManyMutationInput!, where: RequestWhereInput): BatchPayload!
  updateManyStory(data: StoryUpdateManyMutationInput!, where: StoryWhereInput): BatchPayload!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateOneCollection(data: CollectionUpdateInput!, where: CollectionWhereUniqueInput!): Collection!
  updateOneComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment!
  updateOneItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item!
  updateOneLoginToken(data: LoginTokenUpdateInput!, where: LoginTokenWhereUniqueInput!): LoginToken!
  updateOneRefreshToken(data: RefreshTokenUpdateInput!, where: RefreshTokenWhereUniqueInput!): RefreshToken!
  updateOneRequest(data: RequestUpdateInput!, where: RequestWhereUniqueInput!): Request!
  updateOneStory(data: StoryUpdateInput!, where: StoryWhereUniqueInput!): Story!
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  updatePassword(currentPassword: String!, password: String!): Boolean
  upsertOneCollection(create: CollectionCreateInput!, update: CollectionUpdateInput!, where: CollectionWhereUniqueInput!): Collection!
  upsertOneComment(create: CommentCreateInput!, update: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment!
  upsertOneItem(create: ItemCreateInput!, update: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item!
  upsertOneLoginToken(create: LoginTokenCreateInput!, update: LoginTokenUpdateInput!, where: LoginTokenWhereUniqueInput!): LoginToken!
  upsertOneRefreshToken(create: RefreshTokenCreateInput!, update: RefreshTokenUpdateInput!, where: RefreshTokenWhereUniqueInput!): RefreshToken!
  upsertOneRequest(create: RequestCreateInput!, update: RequestUpdateInput!, where: RequestWhereUniqueInput!): Request!
  upsertOneStory(create: StoryCreateInput!, update: StoryUpdateInput!, where: StoryWhereUniqueInput!): Story!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  count: NestedIntFilter
  equals: Boolean
  max: NestedBoolFilter
  min: NestedBoolFilter
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  count: NestedIntNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  max: NestedDateTimeNullableFilter
  min: NestedDateTimeNullableFilter
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  count: NestedIntFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  max: NestedDateTimeFilter
  min: NestedDateTimeFilter
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime]
}

input NestedEnumMessageTypeFilter {
  equals: MessageType
  in: [MessageType]
  not: NestedEnumMessageTypeFilter
  notIn: [MessageType]
}

input NestedEnumMessageTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumMessageTypeFilter
  _min: NestedEnumMessageTypeFilter
  count: NestedIntFilter
  equals: MessageType
  in: [MessageType]
  max: NestedEnumMessageTypeFilter
  min: NestedEnumMessageTypeFilter
  not: NestedEnumMessageTypeWithAggregatesFilter
  notIn: [MessageType]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int]
}

input NestedJsonFilter {
  equals: Json
  not: Json
}

input NestedJsonNullableFilter {
  equals: Json
  not: Json
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  count: NestedIntNullableFilter
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  max: NestedStringNullableFilter
  min: NestedStringNullableFilter
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  count: NestedIntFilter
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  max: NestedStringFilter
  min: NestedStringFilter
  not: NestedStringWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  aggregateCollection(cursor: CollectionWhereUniqueInput, distinct: CollectionScalarFieldEnum, orderBy: [CollectionOrderByInput], skip: Int, take: Int, where: CollectionWhereInput): AggregateCollection
  aggregateComment(cursor: CommentWhereUniqueInput, distinct: CommentScalarFieldEnum, orderBy: [CommentOrderByInput], skip: Int, take: Int, where: CommentWhereInput): AggregateComment
  aggregateItem(cursor: ItemWhereUniqueInput, distinct: ItemScalarFieldEnum, orderBy: [ItemOrderByInput], skip: Int, take: Int, where: ItemWhereInput): AggregateItem
  aggregateLoginToken(cursor: LoginTokenWhereUniqueInput, distinct: LoginTokenScalarFieldEnum, orderBy: [LoginTokenOrderByInput], skip: Int, take: Int, where: LoginTokenWhereInput): AggregateLoginToken
  aggregateRefreshToken(cursor: RefreshTokenWhereUniqueInput, distinct: RefreshTokenScalarFieldEnum, orderBy: [RefreshTokenOrderByInput], skip: Int, take: Int, where: RefreshTokenWhereInput): AggregateRefreshToken
  aggregateRequest(cursor: RequestWhereUniqueInput, distinct: RequestScalarFieldEnum, orderBy: [RequestOrderByInput], skip: Int, take: Int, where: RequestWhereInput): AggregateRequest
  aggregateStory(cursor: StoryWhereUniqueInput, distinct: StoryScalarFieldEnum, orderBy: [StoryOrderByInput], skip: Int, take: Int, where: StoryWhereInput): AggregateStory
  aggregateUser(cursor: UserWhereUniqueInput, distinct: UserScalarFieldEnum, orderBy: [UserOrderByInput], skip: Int, take: Int, where: UserWhereInput): AggregateUser
  findFirstCollection(cursor: CollectionWhereUniqueInput, distinct: CollectionScalarFieldEnum, orderBy: [CollectionOrderByInput], skip: Int, take: Int, where: CollectionWhereInput): Collection
  findFirstComment(cursor: CommentWhereUniqueInput, distinct: CommentScalarFieldEnum, orderBy: [CommentOrderByInput], skip: Int, take: Int, where: CommentWhereInput): Comment
  findFirstItem(cursor: ItemWhereUniqueInput, distinct: ItemScalarFieldEnum, orderBy: [ItemOrderByInput], skip: Int, take: Int, where: ItemWhereInput): Item
  findFirstLoginToken(cursor: LoginTokenWhereUniqueInput, distinct: LoginTokenScalarFieldEnum, orderBy: [LoginTokenOrderByInput], skip: Int, take: Int, where: LoginTokenWhereInput): LoginToken
  findFirstRefreshToken(cursor: RefreshTokenWhereUniqueInput, distinct: RefreshTokenScalarFieldEnum, orderBy: [RefreshTokenOrderByInput], skip: Int, take: Int, where: RefreshTokenWhereInput): RefreshToken
  findFirstRequest(cursor: RequestWhereUniqueInput, distinct: RequestScalarFieldEnum, orderBy: [RequestOrderByInput], skip: Int, take: Int, where: RequestWhereInput): Request
  findFirstStory(cursor: StoryWhereUniqueInput, distinct: StoryScalarFieldEnum, orderBy: [StoryOrderByInput], skip: Int, take: Int, where: StoryWhereInput): Story
  findFirstUser(cursor: UserWhereUniqueInput, distinct: UserScalarFieldEnum, orderBy: [UserOrderByInput], skip: Int, take: Int, where: UserWhereInput): User
  findManyCollection(cursor: CollectionWhereUniqueInput, distinct: CollectionScalarFieldEnum, orderBy: [CollectionOrderByInput], skip: Int, take: Int, where: CollectionWhereInput): [Collection!]!
  findManyCollectionCount(cursor: CollectionWhereUniqueInput, distinct: CollectionScalarFieldEnum, orderBy: [CollectionOrderByInput], skip: Int, take: Int, where: CollectionWhereInput): Int!
  findManyComment(cursor: CommentWhereUniqueInput, distinct: CommentScalarFieldEnum, orderBy: [CommentOrderByInput], skip: Int, take: Int, where: CommentWhereInput): [Comment!]!
  findManyCommentCount(cursor: CommentWhereUniqueInput, distinct: CommentScalarFieldEnum, orderBy: [CommentOrderByInput], skip: Int, take: Int, where: CommentWhereInput): Int!
  findManyItem(cursor: ItemWhereUniqueInput, distinct: ItemScalarFieldEnum, orderBy: [ItemOrderByInput], skip: Int, take: Int, where: ItemWhereInput): [Item!]!
  findManyItemCount(cursor: ItemWhereUniqueInput, distinct: ItemScalarFieldEnum, orderBy: [ItemOrderByInput], skip: Int, take: Int, where: ItemWhereInput): Int!
  findManyLoginToken(cursor: LoginTokenWhereUniqueInput, distinct: LoginTokenScalarFieldEnum, orderBy: [LoginTokenOrderByInput], skip: Int, take: Int, where: LoginTokenWhereInput): [LoginToken!]!
  findManyLoginTokenCount(cursor: LoginTokenWhereUniqueInput, distinct: LoginTokenScalarFieldEnum, orderBy: [LoginTokenOrderByInput], skip: Int, take: Int, where: LoginTokenWhereInput): Int!
  findManyRefreshToken(cursor: RefreshTokenWhereUniqueInput, distinct: RefreshTokenScalarFieldEnum, orderBy: [RefreshTokenOrderByInput], skip: Int, take: Int, where: RefreshTokenWhereInput): [RefreshToken!]!
  findManyRefreshTokenCount(cursor: RefreshTokenWhereUniqueInput, distinct: RefreshTokenScalarFieldEnum, orderBy: [RefreshTokenOrderByInput], skip: Int, take: Int, where: RefreshTokenWhereInput): Int!
  findManyRequest(cursor: RequestWhereUniqueInput, distinct: RequestScalarFieldEnum, orderBy: [RequestOrderByInput], skip: Int, take: Int, where: RequestWhereInput): [Request!]!
  findManyRequestCount(cursor: RequestWhereUniqueInput, distinct: RequestScalarFieldEnum, orderBy: [RequestOrderByInput], skip: Int, take: Int, where: RequestWhereInput): Int!
  findManyStory(cursor: StoryWhereUniqueInput, distinct: StoryScalarFieldEnum, orderBy: [StoryOrderByInput], skip: Int, take: Int, where: StoryWhereInput): [Story!]!
  findManyStoryCount(cursor: StoryWhereUniqueInput, distinct: StoryScalarFieldEnum, orderBy: [StoryOrderByInput], skip: Int, take: Int, where: StoryWhereInput): Int!
  findManyUser(cursor: UserWhereUniqueInput, distinct: UserScalarFieldEnum, orderBy: [UserOrderByInput], skip: Int, take: Int, where: UserWhereInput): [User!]!
  findManyUserCount(cursor: UserWhereUniqueInput, distinct: UserScalarFieldEnum, orderBy: [UserOrderByInput], skip: Int, take: Int, where: UserWhereInput): Int!
  findUniqueCollection(where: CollectionWhereUniqueInput!): Collection
  findUniqueComment(where: CommentWhereUniqueInput!): Comment
  findUniqueItem(where: ItemWhereUniqueInput!): Item
  findUniqueLoginToken(where: LoginTokenWhereUniqueInput!): LoginToken
  findUniqueRefreshToken(where: RefreshTokenWhereUniqueInput!): RefreshToken
  findUniqueRequest(where: RequestWhereUniqueInput!): Request
  findUniqueStory(where: StoryWhereUniqueInput!): Story
  findUniqueUser(where: UserWhereUniqueInput!): User
  getFilters(modelName: String!, pagesPath: String!): JSON
  me: User
  permission: JSON
}

enum QueryMode {
  default
  insensitive
}

type RefreshToken {
  createdAt: DateTime!
  expires: DateTime!
  geo: Json!
  ip: String!
  lastActive: DateTime!
  loginTokenId: String!
  user: User!
  userAgent: String!
  userAgentRaw: String!
  userId: String!
  value: String!
}

type RefreshTokenCountAggregateOutputType {
  _all: Int!
  createdAt: Int!
  expires: Int!
  geo: Int!
  ip: Int!
  lastActive: Int!
  loginTokenId: Int!
  userAgent: Int!
  userAgentRaw: Int!
  userId: Int!
  value: Int!
}

input RefreshTokenCreateInput {
  createdAt: DateTime
  expires: DateTime!
  geo: Json!
  ip: String!
  lastActive: DateTime
  loginTokenId: String!
  user: UserCreateNestedOneWithoutRefreshTokensInput!
  userAgent: String!
  userAgentRaw: String!
  value: String!
}

input RefreshTokenCreateManyInput {
  createdAt: DateTime
  expires: DateTime!
  geo: Json!
  ip: String!
  lastActive: DateTime
  loginTokenId: String!
  userAgent: String!
  userAgentRaw: String!
  userId: String!
  value: String!
}

input RefreshTokenCreateManyUserInput {
  createdAt: DateTime
  expires: DateTime!
  geo: Json!
  ip: String!
  lastActive: DateTime
  loginTokenId: String!
  userAgent: String!
  userAgentRaw: String!
  value: String!
}

input RefreshTokenCreateManyUserInputEnvelope {
  data: RefreshTokenCreateManyUserInput!
  skipDuplicates: Boolean
}

input RefreshTokenCreateNestedManyWithoutUserInput {
  connect: [RefreshTokenWhereUniqueInput]
  connectOrCreate: [RefreshTokenCreateOrConnectWithoutUserInput]
  create: [RefreshTokenCreateWithoutUserInput]
  createMany: RefreshTokenCreateManyUserInputEnvelope
}

input RefreshTokenCreateOrConnectWithoutUserInput {
  create: RefreshTokenUncheckedCreateWithoutUserInput!
  where: RefreshTokenWhereUniqueInput!
}

input RefreshTokenCreateWithoutUserInput {
  createdAt: DateTime
  expires: DateTime!
  geo: Json!
  ip: String!
  lastActive: DateTime
  loginTokenId: String!
  userAgent: String!
  userAgentRaw: String!
  value: String!
}

input RefreshTokenListRelationFilter {
  every: RefreshTokenWhereInput
  none: RefreshTokenWhereInput
  some: RefreshTokenWhereInput
}

type RefreshTokenMaxAggregateOutputType {
  createdAt: DateTime
  expires: DateTime
  ip: String
  lastActive: DateTime
  loginTokenId: String
  userAgent: String
  userAgentRaw: String
  userId: String
  value: String
}

type RefreshTokenMinAggregateOutputType {
  createdAt: DateTime
  expires: DateTime
  ip: String
  lastActive: DateTime
  loginTokenId: String
  userAgent: String
  userAgentRaw: String
  userId: String
  value: String
}

input RefreshTokenOrderByInput {
  createdAt: SortOrder
  expires: SortOrder
  geo: SortOrder
  ip: SortOrder
  lastActive: SortOrder
  loginTokenId: SortOrder
  userAgent: SortOrder
  userAgentRaw: SortOrder
  userId: SortOrder
  value: SortOrder
}

enum RefreshTokenScalarFieldEnum {
  createdAt
  expires
  geo
  ip
  lastActive
  loginTokenId
  userAgent
  userAgentRaw
  userId
  value
}

input RefreshTokenScalarWhereInput {
  AND: [RefreshTokenScalarWhereInput]
  NOT: [RefreshTokenScalarWhereInput]
  OR: [RefreshTokenScalarWhereInput]
  createdAt: DateTimeFilter
  expires: DateTimeFilter
  geo: JsonFilter
  ip: StringFilter
  lastActive: DateTimeFilter
  loginTokenId: StringFilter
  userAgent: StringFilter
  userAgentRaw: StringFilter
  userId: StringFilter
  value: StringFilter
}

input RefreshTokenScalarWhereWithAggregatesInput {
  AND: [RefreshTokenScalarWhereWithAggregatesInput]
  NOT: [RefreshTokenScalarWhereWithAggregatesInput]
  OR: [RefreshTokenScalarWhereWithAggregatesInput]
  createdAt: DateTimeWithAggregatesFilter
  expires: DateTimeWithAggregatesFilter
  geo: JsonWithAggregatesFilter
  ip: StringWithAggregatesFilter
  lastActive: DateTimeWithAggregatesFilter
  loginTokenId: StringWithAggregatesFilter
  userAgent: StringWithAggregatesFilter
  userAgentRaw: StringWithAggregatesFilter
  userId: StringWithAggregatesFilter
  value: StringWithAggregatesFilter
}

input RefreshTokenUncheckedCreateInput {
  createdAt: DateTime
  expires: DateTime!
  geo: Json!
  ip: String!
  lastActive: DateTime
  loginTokenId: String!
  userAgent: String!
  userAgentRaw: String!
  userId: String!
  value: String!
}

input RefreshTokenUncheckedCreateNestedManyWithoutUserInput {
  connect: [RefreshTokenWhereUniqueInput]
  connectOrCreate: [RefreshTokenCreateOrConnectWithoutUserInput]
  create: [RefreshTokenCreateWithoutUserInput]
  createMany: RefreshTokenCreateManyUserInputEnvelope
}

input RefreshTokenUncheckedCreateWithoutUserInput {
  createdAt: DateTime
  expires: DateTime!
  geo: Json!
  ip: String!
  lastActive: DateTime
  loginTokenId: String!
  userAgent: String!
  userAgentRaw: String!
  value: String!
}

input RefreshTokenUncheckedUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  ip: StringFieldUpdateOperationsInput
  lastActive: DateTimeFieldUpdateOperationsInput
  loginTokenId: StringFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
  userId: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input RefreshTokenUncheckedUpdateManyInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  ip: StringFieldUpdateOperationsInput
  lastActive: DateTimeFieldUpdateOperationsInput
  loginTokenId: StringFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
  userId: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input RefreshTokenUncheckedUpdateManyWithoutRefreshTokensInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  ip: StringFieldUpdateOperationsInput
  lastActive: DateTimeFieldUpdateOperationsInput
  loginTokenId: StringFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input RefreshTokenUncheckedUpdateManyWithoutUserInput {
  connect: [RefreshTokenWhereUniqueInput]
  connectOrCreate: [RefreshTokenCreateOrConnectWithoutUserInput]
  create: [RefreshTokenCreateWithoutUserInput]
  createMany: RefreshTokenCreateManyUserInputEnvelope
  delete: [RefreshTokenWhereUniqueInput]
  deleteMany: [RefreshTokenScalarWhereInput]
  disconnect: [RefreshTokenWhereUniqueInput]
  set: [RefreshTokenWhereUniqueInput]
  update: [RefreshTokenUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [RefreshTokenUpdateManyWithWhereWithoutUserInput]
  upsert: [RefreshTokenUpsertWithWhereUniqueWithoutUserInput]
}

input RefreshTokenUncheckedUpdateWithoutUserInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  ip: StringFieldUpdateOperationsInput
  lastActive: DateTimeFieldUpdateOperationsInput
  loginTokenId: StringFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input RefreshTokenUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  ip: StringFieldUpdateOperationsInput
  lastActive: DateTimeFieldUpdateOperationsInput
  loginTokenId: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutRefreshTokensInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input RefreshTokenUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  ip: StringFieldUpdateOperationsInput
  lastActive: DateTimeFieldUpdateOperationsInput
  loginTokenId: StringFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input RefreshTokenUpdateManyWithWhereWithoutUserInput {
  data: RefreshTokenUncheckedUpdateManyWithoutRefreshTokensInput!
  where: RefreshTokenScalarWhereInput!
}

input RefreshTokenUpdateManyWithoutUserInput {
  connect: [RefreshTokenWhereUniqueInput]
  connectOrCreate: [RefreshTokenCreateOrConnectWithoutUserInput]
  create: [RefreshTokenCreateWithoutUserInput]
  createMany: RefreshTokenCreateManyUserInputEnvelope
  delete: [RefreshTokenWhereUniqueInput]
  deleteMany: [RefreshTokenScalarWhereInput]
  disconnect: [RefreshTokenWhereUniqueInput]
  set: [RefreshTokenWhereUniqueInput]
  update: [RefreshTokenUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [RefreshTokenUpdateManyWithWhereWithoutUserInput]
  upsert: [RefreshTokenUpsertWithWhereUniqueWithoutUserInput]
}

input RefreshTokenUpdateWithWhereUniqueWithoutUserInput {
  data: RefreshTokenUncheckedUpdateWithoutUserInput!
  where: RefreshTokenWhereUniqueInput!
}

input RefreshTokenUpdateWithoutUserInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  geo: Json
  ip: StringFieldUpdateOperationsInput
  lastActive: DateTimeFieldUpdateOperationsInput
  loginTokenId: StringFieldUpdateOperationsInput
  userAgent: StringFieldUpdateOperationsInput
  userAgentRaw: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input RefreshTokenUpsertWithWhereUniqueWithoutUserInput {
  create: RefreshTokenUncheckedCreateWithoutUserInput!
  update: RefreshTokenUncheckedUpdateWithoutUserInput!
  where: RefreshTokenWhereUniqueInput!
}

input RefreshTokenWhereInput {
  AND: [RefreshTokenWhereInput]
  NOT: [RefreshTokenWhereInput]
  OR: [RefreshTokenWhereInput]
  createdAt: DateTimeFilter
  expires: DateTimeFilter
  geo: JsonFilter
  ip: StringFilter
  lastActive: DateTimeFilter
  loginTokenId: StringFilter
  user: UserWhereInput
  userAgent: StringFilter
  userAgentRaw: StringFilter
  userId: StringFilter
  value: StringFilter
}

input RefreshTokenWhereUniqueInput {
  loginTokenId: String
}

type Request {
  comments(cursor: CommentWhereUniqueInput, distinct: CommentScalarFieldEnum, orderBy: CommentOrderByInput, skip: Int, take: Int, where: CommentWhereInput): [Comment!]!
  endDate: DateTime
  id: String!
  name: String!
  startDate: DateTime
  story: Story!
  storyId: String!
}

type RequestCountAggregateOutputType {
  _all: Int!
  endDate: Int!
  id: Int!
  name: Int!
  startDate: Int!
  storyId: Int!
}

input RequestCreateInput {
  comments: CommentCreateNestedManyWithoutRequestInput
  endDate: DateTime
  id: String
  name: String!
  startDate: DateTime
  story: StoryCreateNestedOneWithoutRequestsInput!
}

input RequestCreateManyInput {
  endDate: DateTime
  id: String
  name: String!
  startDate: DateTime
  storyId: String!
}

input RequestCreateManyStoryInput {
  endDate: DateTime
  id: String
  name: String!
  startDate: DateTime
}

input RequestCreateManyStoryInputEnvelope {
  data: RequestCreateManyStoryInput!
  skipDuplicates: Boolean
}

input RequestCreateNestedManyWithoutStoryInput {
  connect: [RequestWhereUniqueInput]
  connectOrCreate: [RequestCreateOrConnectWithoutStoryInput]
  create: [RequestCreateWithoutStoryInput]
  createMany: RequestCreateManyStoryInputEnvelope
}

input RequestCreateNestedOneWithoutCommentsInput {
  connect: RequestWhereUniqueInput
  connectOrCreate: RequestCreateOrConnectWithoutCommentsInput
  create: RequestUncheckedCreateWithoutCommentsInput
}

input RequestCreateOrConnectWithoutCommentsInput {
  create: RequestUncheckedCreateWithoutCommentsInput!
  where: RequestWhereUniqueInput!
}

input RequestCreateOrConnectWithoutStoryInput {
  create: RequestUncheckedCreateWithoutStoryInput!
  where: RequestWhereUniqueInput!
}

input RequestCreateWithoutCommentsInput {
  endDate: DateTime
  id: String
  name: String!
  startDate: DateTime
  story: StoryCreateNestedOneWithoutRequestsInput!
}

input RequestCreateWithoutStoryInput {
  comments: CommentCreateNestedManyWithoutRequestInput
  endDate: DateTime
  id: String
  name: String!
  startDate: DateTime
}

input RequestListRelationFilter {
  every: RequestWhereInput
  none: RequestWhereInput
  some: RequestWhereInput
}

type RequestMaxAggregateOutputType {
  endDate: DateTime
  id: String
  name: String
  startDate: DateTime
  storyId: String
}

type RequestMinAggregateOutputType {
  endDate: DateTime
  id: String
  name: String
  startDate: DateTime
  storyId: String
}

input RequestOrderByInput {
  endDate: SortOrder
  id: SortOrder
  name: SortOrder
  startDate: SortOrder
  storyId: SortOrder
}

input RequestRelationFilter {
  is: RequestWhereInput
  isNot: RequestWhereInput
}

enum RequestScalarFieldEnum {
  endDate
  id
  name
  startDate
  storyId
}

input RequestScalarWhereInput {
  AND: [RequestScalarWhereInput]
  NOT: [RequestScalarWhereInput]
  OR: [RequestScalarWhereInput]
  endDate: DateTimeNullableFilter
  id: StringFilter
  name: StringFilter
  startDate: DateTimeNullableFilter
  storyId: StringFilter
}

input RequestScalarWhereWithAggregatesInput {
  AND: [RequestScalarWhereWithAggregatesInput]
  NOT: [RequestScalarWhereWithAggregatesInput]
  OR: [RequestScalarWhereWithAggregatesInput]
  endDate: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  startDate: DateTimeNullableWithAggregatesFilter
  storyId: StringWithAggregatesFilter
}

input RequestUncheckedCreateInput {
  comments: CommentUncheckedCreateNestedManyWithoutRequestInput
  endDate: DateTime
  id: String
  name: String!
  startDate: DateTime
  storyId: String!
}

input RequestUncheckedCreateNestedManyWithoutStoryInput {
  connect: [RequestWhereUniqueInput]
  connectOrCreate: [RequestCreateOrConnectWithoutStoryInput]
  create: [RequestCreateWithoutStoryInput]
  createMany: RequestCreateManyStoryInputEnvelope
}

input RequestUncheckedCreateWithoutCommentsInput {
  endDate: DateTime
  id: String
  name: String!
  startDate: DateTime
  storyId: String!
}

input RequestUncheckedCreateWithoutStoryInput {
  comments: CommentUncheckedCreateNestedManyWithoutRequestInput
  endDate: DateTime
  id: String
  name: String!
  startDate: DateTime
}

input RequestUncheckedUpdateInput {
  comments: CommentUncheckedUpdateManyWithoutRequestInput
  endDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  startDate: NullableDateTimeFieldUpdateOperationsInput
  storyId: StringFieldUpdateOperationsInput
}

input RequestUncheckedUpdateManyInput {
  endDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  startDate: NullableDateTimeFieldUpdateOperationsInput
  storyId: StringFieldUpdateOperationsInput
}

input RequestUncheckedUpdateManyWithoutRequestsInput {
  endDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  startDate: NullableDateTimeFieldUpdateOperationsInput
}

input RequestUncheckedUpdateManyWithoutStoryInput {
  connect: [RequestWhereUniqueInput]
  connectOrCreate: [RequestCreateOrConnectWithoutStoryInput]
  create: [RequestCreateWithoutStoryInput]
  createMany: RequestCreateManyStoryInputEnvelope
  delete: [RequestWhereUniqueInput]
  deleteMany: [RequestScalarWhereInput]
  disconnect: [RequestWhereUniqueInput]
  set: [RequestWhereUniqueInput]
  update: [RequestUpdateWithWhereUniqueWithoutStoryInput]
  updateMany: [RequestUpdateManyWithWhereWithoutStoryInput]
  upsert: [RequestUpsertWithWhereUniqueWithoutStoryInput]
}

input RequestUncheckedUpdateWithoutCommentsInput {
  endDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  startDate: NullableDateTimeFieldUpdateOperationsInput
  storyId: StringFieldUpdateOperationsInput
}

input RequestUncheckedUpdateWithoutStoryInput {
  comments: CommentUncheckedUpdateManyWithoutRequestInput
  endDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  startDate: NullableDateTimeFieldUpdateOperationsInput
}

input RequestUpdateInput {
  comments: CommentUpdateManyWithoutRequestInput
  endDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  startDate: NullableDateTimeFieldUpdateOperationsInput
  story: StoryUpdateOneRequiredWithoutRequestsInput
}

input RequestUpdateManyMutationInput {
  endDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  startDate: NullableDateTimeFieldUpdateOperationsInput
}

input RequestUpdateManyWithWhereWithoutStoryInput {
  data: RequestUncheckedUpdateManyWithoutRequestsInput!
  where: RequestScalarWhereInput!
}

input RequestUpdateManyWithoutStoryInput {
  connect: [RequestWhereUniqueInput]
  connectOrCreate: [RequestCreateOrConnectWithoutStoryInput]
  create: [RequestCreateWithoutStoryInput]
  createMany: RequestCreateManyStoryInputEnvelope
  delete: [RequestWhereUniqueInput]
  deleteMany: [RequestScalarWhereInput]
  disconnect: [RequestWhereUniqueInput]
  set: [RequestWhereUniqueInput]
  update: [RequestUpdateWithWhereUniqueWithoutStoryInput]
  updateMany: [RequestUpdateManyWithWhereWithoutStoryInput]
  upsert: [RequestUpsertWithWhereUniqueWithoutStoryInput]
}

input RequestUpdateOneRequiredWithoutCommentsInput {
  connect: RequestWhereUniqueInput
  connectOrCreate: RequestCreateOrConnectWithoutCommentsInput
  create: RequestUncheckedCreateWithoutCommentsInput
  update: RequestUncheckedUpdateWithoutCommentsInput
  upsert: RequestUpsertWithoutCommentsInput
}

input RequestUpdateWithWhereUniqueWithoutStoryInput {
  data: RequestUncheckedUpdateWithoutStoryInput!
  where: RequestWhereUniqueInput!
}

input RequestUpdateWithoutCommentsInput {
  endDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  startDate: NullableDateTimeFieldUpdateOperationsInput
  story: StoryUpdateOneRequiredWithoutRequestsInput
}

input RequestUpdateWithoutStoryInput {
  comments: CommentUpdateManyWithoutRequestInput
  endDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  startDate: NullableDateTimeFieldUpdateOperationsInput
}

input RequestUpsertWithWhereUniqueWithoutStoryInput {
  create: RequestUncheckedCreateWithoutStoryInput!
  update: RequestUncheckedUpdateWithoutStoryInput!
  where: RequestWhereUniqueInput!
}

input RequestUpsertWithoutCommentsInput {
  create: RequestUncheckedCreateWithoutCommentsInput!
  update: RequestUncheckedUpdateWithoutCommentsInput!
}

input RequestWhereInput {
  AND: [RequestWhereInput]
  NOT: [RequestWhereInput]
  OR: [RequestWhereInput]
  comments: CommentListRelationFilter
  endDate: DateTimeNullableFilter
  id: StringFilter
  name: StringFilter
  startDate: DateTimeNullableFilter
  story: StoryWhereInput
  storyId: StringFilter
}

input RequestWhereUniqueInput {
  id: String
}

enum SortOrder {
  asc
  desc
}

type Story {
  collection: Collection!
  collectionId: String!
  description: String
  doImage: Json
  id: String!
  itemIds: [String!]!
  items(cursor: ItemWhereUniqueInput, distinct: ItemScalarFieldEnum, orderBy: ItemOrderByInput, skip: Int, take: Int, where: ItemWhereInput): [Item!]!
  name: String!
  requests(cursor: RequestWhereUniqueInput, distinct: RequestScalarFieldEnum, orderBy: RequestOrderByInput, skip: Int, take: Int, where: RequestWhereInput): [Request!]!
}

type StoryCountAggregateOutputType {
  _all: Int!
  collectionId: Int!
  description: Int!
  doImage: Int!
  id: Int!
  itemIds: Int!
  name: Int!
}

input StoryCreateInput {
  collection: CollectionCreateNestedOneWithoutStoriesInput!
  description: String
  doImage: Json
  id: String
  itemIds: [String]
  items: ItemCreateNestedManyWithoutStoriesInput
  name: String!
  requests: RequestCreateNestedManyWithoutStoryInput
}

input StoryCreateManyCollectionInput {
  description: String
  doImage: Json
  id: String
  itemIds: [String]
  name: String!
}

input StoryCreateManyCollectionInputEnvelope {
  data: StoryCreateManyCollectionInput!
  skipDuplicates: Boolean
}

input StoryCreateManyInput {
  collectionId: String!
  description: String
  doImage: Json
  id: String
  itemIds: [String]
  name: String!
}

input StoryCreateManyitemIdsInput {
  set: String!
}

input StoryCreateNestedManyWithoutCollectionInput {
  connect: [StoryWhereUniqueInput]
  connectOrCreate: [StoryCreateOrConnectWithoutCollectionInput]
  create: [StoryCreateWithoutCollectionInput]
  createMany: StoryCreateManyCollectionInputEnvelope
}

input StoryCreateNestedManyWithoutItemsInput {
  connect: [StoryWhereUniqueInput]
  connectOrCreate: [StoryCreateOrConnectWithoutItemsInput]
  create: [StoryCreateWithoutItemsInput]
}

input StoryCreateNestedOneWithoutRequestsInput {
  connect: StoryWhereUniqueInput
  connectOrCreate: StoryCreateOrConnectWithoutRequestsInput
  create: StoryUncheckedCreateWithoutRequestsInput
}

input StoryCreateOrConnectWithoutCollectionInput {
  create: StoryUncheckedCreateWithoutCollectionInput!
  where: StoryWhereUniqueInput!
}

input StoryCreateOrConnectWithoutItemsInput {
  create: StoryUncheckedCreateWithoutItemsInput!
  where: StoryWhereUniqueInput!
}

input StoryCreateOrConnectWithoutRequestsInput {
  create: StoryUncheckedCreateWithoutRequestsInput!
  where: StoryWhereUniqueInput!
}

input StoryCreateWithoutCollectionInput {
  description: String
  doImage: Json
  id: String
  itemIds: [String]
  items: ItemCreateNestedManyWithoutStoriesInput
  name: String!
  requests: RequestCreateNestedManyWithoutStoryInput
}

input StoryCreateWithoutItemsInput {
  collection: CollectionCreateNestedOneWithoutStoriesInput!
  description: String
  doImage: Json
  id: String
  itemIds: [String]
  name: String!
  requests: RequestCreateNestedManyWithoutStoryInput
}

input StoryCreateWithoutRequestsInput {
  collection: CollectionCreateNestedOneWithoutStoriesInput!
  description: String
  doImage: Json
  id: String
  itemIds: [String]
  items: ItemCreateNestedManyWithoutStoriesInput
  name: String!
}

input StoryCreateitemIdsInput {
  set: String!
}

input StoryListRelationFilter {
  every: StoryWhereInput
  none: StoryWhereInput
  some: StoryWhereInput
}

type StoryMaxAggregateOutputType {
  collectionId: String
  description: String
  id: String
  name: String
}

type StoryMinAggregateOutputType {
  collectionId: String
  description: String
  id: String
  name: String
}

input StoryOrderByInput {
  collectionId: SortOrder
  description: SortOrder
  doImage: SortOrder
  id: SortOrder
  itemIds: SortOrder
  name: SortOrder
}

input StoryRelationFilter {
  is: StoryWhereInput
  isNot: StoryWhereInput
}

enum StoryScalarFieldEnum {
  collectionId
  description
  doImage
  id
  itemIds
  name
}

input StoryScalarWhereInput {
  AND: [StoryScalarWhereInput]
  NOT: [StoryScalarWhereInput]
  OR: [StoryScalarWhereInput]
  collectionId: StringFilter
  description: StringNullableFilter
  doImage: JsonNullableFilter
  id: StringFilter
  itemIds: StringNullableListFilter
  name: StringFilter
}

input StoryScalarWhereWithAggregatesInput {
  AND: [StoryScalarWhereWithAggregatesInput]
  NOT: [StoryScalarWhereWithAggregatesInput]
  OR: [StoryScalarWhereWithAggregatesInput]
  collectionId: StringWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  doImage: JsonNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  itemIds: StringNullableListFilter
  name: StringWithAggregatesFilter
}

input StoryUncheckedCreateInput {
  collectionId: String!
  description: String
  doImage: Json
  id: String
  itemIds: [String]
  name: String!
  requests: RequestUncheckedCreateNestedManyWithoutStoryInput
}

input StoryUncheckedCreateNestedManyWithoutCollectionInput {
  connect: [StoryWhereUniqueInput]
  connectOrCreate: [StoryCreateOrConnectWithoutCollectionInput]
  create: [StoryCreateWithoutCollectionInput]
  createMany: StoryCreateManyCollectionInputEnvelope
}

input StoryUncheckedCreateWithoutCollectionInput {
  description: String
  doImage: Json
  id: String
  itemIds: [String]
  name: String!
  requests: RequestUncheckedCreateNestedManyWithoutStoryInput
}

input StoryUncheckedCreateWithoutItemsInput {
  collectionId: String!
  description: String
  doImage: Json
  id: String
  itemIds: [String]
  name: String!
  requests: RequestUncheckedCreateNestedManyWithoutStoryInput
}

input StoryUncheckedCreateWithoutRequestsInput {
  collectionId: String!
  description: String
  doImage: Json
  id: String
  itemIds: [String]
  name: String!
}

input StoryUncheckedUpdateInput {
  collectionId: StringFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  itemIds: [String]
  name: StringFieldUpdateOperationsInput
  requests: RequestUncheckedUpdateManyWithoutStoryInput
}

input StoryUncheckedUpdateManyInput {
  collectionId: StringFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  itemIds: [String]
  name: StringFieldUpdateOperationsInput
}

input StoryUncheckedUpdateManyWithoutCollectionInput {
  connect: [StoryWhereUniqueInput]
  connectOrCreate: [StoryCreateOrConnectWithoutCollectionInput]
  create: [StoryCreateWithoutCollectionInput]
  createMany: StoryCreateManyCollectionInputEnvelope
  delete: [StoryWhereUniqueInput]
  deleteMany: [StoryScalarWhereInput]
  disconnect: [StoryWhereUniqueInput]
  set: [StoryWhereUniqueInput]
  update: [StoryUpdateWithWhereUniqueWithoutCollectionInput]
  updateMany: [StoryUpdateManyWithWhereWithoutCollectionInput]
  upsert: [StoryUpsertWithWhereUniqueWithoutCollectionInput]
}

input StoryUncheckedUpdateManyWithoutStoriesInput {
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  itemIds: [String]
  name: StringFieldUpdateOperationsInput
}

input StoryUncheckedUpdateWithoutCollectionInput {
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  itemIds: [String]
  name: StringFieldUpdateOperationsInput
  requests: RequestUncheckedUpdateManyWithoutStoryInput
}

input StoryUncheckedUpdateWithoutItemsInput {
  collectionId: StringFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  itemIds: [String]
  name: StringFieldUpdateOperationsInput
  requests: RequestUncheckedUpdateManyWithoutStoryInput
}

input StoryUncheckedUpdateWithoutRequestsInput {
  collectionId: StringFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  itemIds: [String]
  name: StringFieldUpdateOperationsInput
}

input StoryUpdateInput {
  collection: CollectionUpdateOneRequiredWithoutStoriesInput
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  itemIds: [String]
  items: ItemUpdateManyWithoutStoriesInput
  name: StringFieldUpdateOperationsInput
  requests: RequestUpdateManyWithoutStoryInput
}

input StoryUpdateManyMutationInput {
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  itemIds: [String]
  name: StringFieldUpdateOperationsInput
}

input StoryUpdateManyWithWhereWithoutCollectionInput {
  data: StoryUncheckedUpdateManyWithoutStoriesInput!
  where: StoryScalarWhereInput!
}

input StoryUpdateManyWithWhereWithoutItemsInput {
  data: StoryUncheckedUpdateManyWithoutStoriesInput!
  where: StoryScalarWhereInput!
}

input StoryUpdateManyWithoutCollectionInput {
  connect: [StoryWhereUniqueInput]
  connectOrCreate: [StoryCreateOrConnectWithoutCollectionInput]
  create: [StoryCreateWithoutCollectionInput]
  createMany: StoryCreateManyCollectionInputEnvelope
  delete: [StoryWhereUniqueInput]
  deleteMany: [StoryScalarWhereInput]
  disconnect: [StoryWhereUniqueInput]
  set: [StoryWhereUniqueInput]
  update: [StoryUpdateWithWhereUniqueWithoutCollectionInput]
  updateMany: [StoryUpdateManyWithWhereWithoutCollectionInput]
  upsert: [StoryUpsertWithWhereUniqueWithoutCollectionInput]
}

input StoryUpdateManyWithoutItemsInput {
  connect: [StoryWhereUniqueInput]
  connectOrCreate: [StoryCreateOrConnectWithoutItemsInput]
  create: [StoryCreateWithoutItemsInput]
  delete: [StoryWhereUniqueInput]
  deleteMany: [StoryScalarWhereInput]
  disconnect: [StoryWhereUniqueInput]
  set: [StoryWhereUniqueInput]
  update: [StoryUpdateWithWhereUniqueWithoutItemsInput]
  updateMany: [StoryUpdateManyWithWhereWithoutItemsInput]
  upsert: [StoryUpsertWithWhereUniqueWithoutItemsInput]
}

input StoryUpdateOneRequiredWithoutRequestsInput {
  connect: StoryWhereUniqueInput
  connectOrCreate: StoryCreateOrConnectWithoutRequestsInput
  create: StoryUncheckedCreateWithoutRequestsInput
  update: StoryUncheckedUpdateWithoutRequestsInput
  upsert: StoryUpsertWithoutRequestsInput
}

input StoryUpdateWithWhereUniqueWithoutCollectionInput {
  data: StoryUncheckedUpdateWithoutCollectionInput!
  where: StoryWhereUniqueInput!
}

input StoryUpdateWithWhereUniqueWithoutItemsInput {
  data: StoryUncheckedUpdateWithoutItemsInput!
  where: StoryWhereUniqueInput!
}

input StoryUpdateWithoutCollectionInput {
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  itemIds: [String]
  items: ItemUpdateManyWithoutStoriesInput
  name: StringFieldUpdateOperationsInput
  requests: RequestUpdateManyWithoutStoryInput
}

input StoryUpdateWithoutItemsInput {
  collection: CollectionUpdateOneRequiredWithoutStoriesInput
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  itemIds: [String]
  name: StringFieldUpdateOperationsInput
  requests: RequestUpdateManyWithoutStoryInput
}

input StoryUpdateWithoutRequestsInput {
  collection: CollectionUpdateOneRequiredWithoutStoriesInput
  description: NullableStringFieldUpdateOperationsInput
  doImage: Json
  id: StringFieldUpdateOperationsInput
  itemIds: [String]
  items: ItemUpdateManyWithoutStoriesInput
  name: StringFieldUpdateOperationsInput
}

input StoryUpdateitemIdsInput {
  push: [String]
  set: [String]
}

input StoryUpsertWithWhereUniqueWithoutCollectionInput {
  create: StoryUncheckedCreateWithoutCollectionInput!
  update: StoryUncheckedUpdateWithoutCollectionInput!
  where: StoryWhereUniqueInput!
}

input StoryUpsertWithWhereUniqueWithoutItemsInput {
  create: StoryUncheckedCreateWithoutItemsInput!
  update: StoryUncheckedUpdateWithoutItemsInput!
  where: StoryWhereUniqueInput!
}

input StoryUpsertWithoutRequestsInput {
  create: StoryUncheckedCreateWithoutRequestsInput!
  update: StoryUncheckedUpdateWithoutRequestsInput!
}

input StoryWhereInput {
  AND: [StoryWhereInput]
  NOT: [StoryWhereInput]
  OR: [StoryWhereInput]
  collection: CollectionWhereInput
  collectionId: StringFilter
  description: StringNullableFilter
  doImage: JsonNullableFilter
  id: StringFilter
  itemIds: StringNullableListFilter
  items: ItemListRelationFilter
  name: StringFilter
  requests: RequestListRelationFilter
}

input StoryWhereUniqueInput {
  id: String
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String]
  startsWith: String
}

input StringNullableListFilter {
  equals: [String]
  has: String
  hasEvery: [String]
  hasSome: [String]
  isEmpty: Boolean
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  count: NestedIntNullableFilter
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  max: NestedStringNullableFilter
  min: NestedStringNullableFilter
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  count: NestedIntFilter
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  max: NestedStringFilter
  min: NestedStringFilter
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

type User {
  comments(cursor: CommentWhereUniqueInput, distinct: CommentScalarFieldEnum, orderBy: CommentOrderByInput, skip: Int, take: Int, where: CommentWhereInput): [Comment!]!
  createdAt: DateTime!
  doImage: Json
  email: String!
  id: String!
  loginTokens(cursor: LoginTokenWhereUniqueInput, distinct: LoginTokenScalarFieldEnum, orderBy: LoginTokenOrderByInput, skip: Int, take: Int, where: LoginTokenWhereInput): [LoginToken!]!
  name: String
  password: String
  refreshTokens(cursor: RefreshTokenWhereUniqueInput, distinct: RefreshTokenScalarFieldEnum, orderBy: RefreshTokenOrderByInput, skip: Int, take: Int, where: RefreshTokenWhereInput): [RefreshToken!]!
  updatedAt: DateTime!
}

type UserCountAggregateOutputType {
  _all: Int!
  createdAt: Int!
  doImage: Int!
  email: Int!
  id: Int!
  name: Int!
  password: Int!
  updatedAt: Int!
}

input UserCreateInput {
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: DateTime
  doImage: Json
  email: String!
  id: String
  loginTokens: LoginTokenCreateNestedManyWithoutUserInput
  name: String
  password: String
  refreshTokens: RefreshTokenCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateManyInput {
  createdAt: DateTime
  doImage: Json
  email: String!
  id: String
  name: String
  password: String
  updatedAt: DateTime
}

input UserCreateNestedOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  create: UserUncheckedCreateWithoutCommentsInput
}

input UserCreateNestedOneWithoutLoginTokensInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutLoginTokensInput
  create: UserUncheckedCreateWithoutLoginTokensInput
}

input UserCreateNestedOneWithoutRefreshTokensInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRefreshTokensInput
  create: UserUncheckedCreateWithoutRefreshTokensInput
}

input UserCreateOrConnectWithoutCommentsInput {
  create: UserUncheckedCreateWithoutCommentsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutLoginTokensInput {
  create: UserUncheckedCreateWithoutLoginTokensInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutRefreshTokensInput {
  create: UserUncheckedCreateWithoutRefreshTokensInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutCommentsInput {
  createdAt: DateTime
  doImage: Json
  email: String!
  id: String
  loginTokens: LoginTokenCreateNestedManyWithoutUserInput
  name: String
  password: String
  refreshTokens: RefreshTokenCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateWithoutLoginTokensInput {
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: DateTime
  doImage: Json
  email: String!
  id: String
  name: String
  password: String
  refreshTokens: RefreshTokenCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateWithoutRefreshTokensInput {
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: DateTime
  doImage: Json
  email: String!
  id: String
  loginTokens: LoginTokenCreateNestedManyWithoutUserInput
  name: String
  password: String
  updatedAt: DateTime
}

type UserMaxAggregateOutputType {
  createdAt: DateTime
  email: String
  id: String
  name: String
  password: String
  updatedAt: DateTime
}

type UserMinAggregateOutputType {
  createdAt: DateTime
  email: String
  id: String
  name: String
  password: String
  updatedAt: DateTime
}

input UserOrderByInput {
  createdAt: SortOrder
  doImage: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  doImage
  email
  id
  name
  password
  updatedAt
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput]
  NOT: [UserScalarWhereWithAggregatesInput]
  OR: [UserScalarWhereWithAggregatesInput]
  createdAt: DateTimeWithAggregatesFilter
  doImage: JsonNullableWithAggregatesFilter
  email: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringNullableWithAggregatesFilter
  password: StringNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input UserUncheckedCreateInput {
  comments: CommentUncheckedCreateNestedManyWithoutUserInput
  createdAt: DateTime
  doImage: Json
  email: String!
  id: String
  loginTokens: LoginTokenUncheckedCreateNestedManyWithoutUserInput
  name: String
  password: String
  refreshTokens: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserUncheckedCreateWithoutCommentsInput {
  createdAt: DateTime
  doImage: Json
  email: String!
  id: String
  loginTokens: LoginTokenUncheckedCreateNestedManyWithoutUserInput
  name: String
  password: String
  refreshTokens: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserUncheckedCreateWithoutLoginTokensInput {
  comments: CommentUncheckedCreateNestedManyWithoutUserInput
  createdAt: DateTime
  doImage: Json
  email: String!
  id: String
  name: String
  password: String
  refreshTokens: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserUncheckedCreateWithoutRefreshTokensInput {
  comments: CommentUncheckedCreateNestedManyWithoutUserInput
  createdAt: DateTime
  doImage: Json
  email: String!
  id: String
  loginTokens: LoginTokenUncheckedCreateNestedManyWithoutUserInput
  name: String
  password: String
  updatedAt: DateTime
}

input UserUncheckedUpdateInput {
  comments: CommentUncheckedUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  doImage: Json
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  loginTokens: LoginTokenUncheckedUpdateManyWithoutUserInput
  name: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  refreshTokens: RefreshTokenUncheckedUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUncheckedUpdateManyInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  doImage: Json
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUncheckedUpdateWithoutCommentsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  doImage: Json
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  loginTokens: LoginTokenUncheckedUpdateManyWithoutUserInput
  name: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  refreshTokens: RefreshTokenUncheckedUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUncheckedUpdateWithoutLoginTokensInput {
  comments: CommentUncheckedUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  doImage: Json
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  refreshTokens: RefreshTokenUncheckedUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUncheckedUpdateWithoutRefreshTokensInput {
  comments: CommentUncheckedUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  doImage: Json
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  loginTokens: LoginTokenUncheckedUpdateManyWithoutUserInput
  name: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateInput {
  comments: CommentUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  doImage: Json
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  loginTokens: LoginTokenUpdateManyWithoutUserInput
  name: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  refreshTokens: RefreshTokenUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  doImage: Json
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutCommentsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  create: UserUncheckedCreateWithoutCommentsInput
  update: UserUncheckedUpdateWithoutCommentsInput
  upsert: UserUpsertWithoutCommentsInput
}

input UserUpdateOneRequiredWithoutLoginTokensInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutLoginTokensInput
  create: UserUncheckedCreateWithoutLoginTokensInput
  update: UserUncheckedUpdateWithoutLoginTokensInput
  upsert: UserUpsertWithoutLoginTokensInput
}

input UserUpdateOneRequiredWithoutRefreshTokensInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRefreshTokensInput
  create: UserUncheckedCreateWithoutRefreshTokensInput
  update: UserUncheckedUpdateWithoutRefreshTokensInput
  upsert: UserUpsertWithoutRefreshTokensInput
}

input UserUpdateWithoutCommentsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  doImage: Json
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  loginTokens: LoginTokenUpdateManyWithoutUserInput
  name: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  refreshTokens: RefreshTokenUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutLoginTokensInput {
  comments: CommentUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  doImage: Json
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  refreshTokens: RefreshTokenUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutRefreshTokensInput {
  comments: CommentUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  doImage: Json
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  loginTokens: LoginTokenUpdateManyWithoutUserInput
  name: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpsertWithoutCommentsInput {
  create: UserUncheckedCreateWithoutCommentsInput!
  update: UserUncheckedUpdateWithoutCommentsInput!
}

input UserUpsertWithoutLoginTokensInput {
  create: UserUncheckedCreateWithoutLoginTokensInput!
  update: UserUncheckedUpdateWithoutLoginTokensInput!
}

input UserUpsertWithoutRefreshTokensInput {
  create: UserUncheckedCreateWithoutRefreshTokensInput!
  update: UserUncheckedUpdateWithoutRefreshTokensInput!
}

input UserWhereInput {
  AND: [UserWhereInput]
  NOT: [UserWhereInput]
  OR: [UserWhereInput]
  comments: CommentListRelationFilter
  createdAt: DateTimeFilter
  doImage: JsonNullableFilter
  email: StringFilter
  id: StringFilter
  loginTokens: LoginTokenListRelationFilter
  name: StringNullableFilter
  password: StringNullableFilter
  refreshTokens: RefreshTokenListRelationFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}
